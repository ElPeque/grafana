{"version":3,"file":"6814.a0a1709c1f0436564f9a.js","mappings":"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","sources":["webpack://grafana/./public/app/features/alerting/unified/components/notification-policies/ContactPointSelector.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rule-editor/EvaluationGroupQuickPick.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rule-editor/GrafanaAlertStatePicker.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rule-editor/PendingPeriodQuickPick.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rule-editor/GrafanaEvaluationBehavior.tsx","webpack://grafana/./public/app/features/alerting/unified/components/InvalidIntervalWarning.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rules/EditRuleGroupModal.tsx","webpack://grafana/./public/app/features/alerting/unified/hooks/ruleGroup/useUpdateRuleGroup.ts","webpack://grafana/./public/app/features/alerting/unified/utils/accessControlHooks.ts"],"sourcesContent":["import { css, cx, keyframes } from '@emotion/css';\nimport { useMemo, useState } from 'react';\n\nimport { GrafanaTheme2, SelectableValue } from '@grafana/data';\nimport { Alert, IconButton, Select, SelectCommonProps, Stack, Text, useStyles2 } from '@grafana/ui';\nimport { ContactPointReceiverSummary } from 'app/features/alerting/unified/components/contact-points/ContactPoint';\nimport { useAlertmanager } from 'app/features/alerting/unified/state/AlertmanagerContext';\n\nimport { useContactPointsWithStatus } from '../contact-points/useContactPoints';\nimport { ContactPointWithMetadata } from '../contact-points/utils';\n\nconst MAX_CONTACT_POINTS_RENDERED = 500;\n\n// Mock sleep method, as fetching receivers is very fast and may seem like it hasn't occurred\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\nconst LOADING_SPINNER_DURATION = 1000;\n\ntype ContactPointSelectorProps = {\n  selectProps: SelectCommonProps<ContactPointWithMetadata>;\n  showRefreshButton?: boolean;\n  /** Name of a contact point to optionally find and set as the preset value on the dropdown */\n  selectedContactPointName?: string | null;\n};\n\nexport const ContactPointSelector = ({\n  selectProps,\n  showRefreshButton,\n  selectedContactPointName,\n}: ContactPointSelectorProps) => {\n  const { selectedAlertmanager } = useAlertmanager();\n  const { contactPoints, isLoading, error, refetch } = useContactPointsWithStatus({\n    alertmanager: selectedAlertmanager!,\n  });\n  const [loaderSpinning, setLoaderSpinning] = useState(false);\n  const styles = useStyles2(getStyles);\n\n  const options: Array<SelectableValue<ContactPointWithMetadata>> = contactPoints.map((contactPoint) => {\n    return {\n      label: contactPoint.name,\n      value: contactPoint,\n      component: () => (\n        <Text variant=\"bodySmall\" color=\"secondary\">\n          <ContactPointReceiverSummary receivers={contactPoint.grafana_managed_receiver_configs} limit={2} />\n        </Text>\n      ),\n    };\n  });\n\n  const matchedContactPoint: SelectableValue<ContactPointWithMetadata> | null = useMemo(() => {\n    return options.find((option) => option.value?.name === selectedContactPointName) || null;\n  }, [options, selectedContactPointName]);\n\n  // force some minimum wait period for fetching contact points\n  const onClickRefresh = () => {\n    setLoaderSpinning(true);\n    Promise.all([refetch(), sleep(LOADING_SPINNER_DURATION)]).finally(() => {\n      setLoaderSpinning(false);\n    });\n  };\n\n  // TODO error handling\n  if (error) {\n    return <Alert title=\"Failed to fetch contact points\" severity=\"error\" />;\n  }\n\n  return (\n    <Stack>\n      <Select\n        virtualized={options.length > MAX_CONTACT_POINTS_RENDERED}\n        options={options}\n        value={matchedContactPoint}\n        {...selectProps}\n        isLoading={isLoading}\n      />\n      {showRefreshButton && (\n        <IconButton\n          name=\"sync\"\n          onClick={onClickRefresh}\n          aria-label=\"Refresh contact points\"\n          tooltip=\"Refresh contact points list\"\n          className={cx(styles.refreshButton, {\n            [styles.loading]: loaderSpinning || isLoading,\n          })}\n        />\n      )}\n    </Stack>\n  );\n};\n\nconst rotation = keyframes({\n  from: {\n    transform: 'rotate(0deg)',\n  },\n  to: {\n    transform: 'rotate(720deg)',\n  },\n});\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  refreshButton: css({\n    color: theme.colors.text.secondary,\n    cursor: 'pointer',\n    borderRadius: theme.shape.radius.circle,\n    overflow: 'hidden',\n  }),\n  loading: css({\n    pointerEvents: 'none',\n    [theme.transitions.handleMotion('no-preference')]: {\n      animation: `${rotation} 2s infinite linear`,\n    },\n    [theme.transitions.handleMotion('reduce')]: {\n      animation: `${rotation} 6s infinite linear`,\n    },\n  }),\n});\n","import { last, times } from 'lodash';\n\nimport { config } from '@grafana/runtime';\nimport { Button, Stack } from '@grafana/ui';\n\nimport { formatPrometheusDuration, parsePrometheusDuration, safeParsePrometheusDuration } from '../../utils/time';\n\nconst MIN_INTERVAl = config.unifiedAlerting.minInterval ?? '10s';\nexport const getEvaluationGroupOptions = (minInterval = MIN_INTERVAl) => {\n  const MIN_OPTIONS_TO_SHOW = 8;\n  const DEFAULT_INTERVAL_OPTIONS: number[] = [\n    parsePrometheusDuration('10s'),\n    parsePrometheusDuration('30s'),\n    parsePrometheusDuration('1m'),\n    parsePrometheusDuration('5m'),\n    parsePrometheusDuration('10m'),\n    parsePrometheusDuration('15m'),\n    parsePrometheusDuration('30m'),\n    parsePrometheusDuration('1h'),\n  ];\n\n  // 10s for OSS and 1m0s for Grafana Cloud\n  const minEvaluationIntervalMillis = safeParsePrometheusDuration(minInterval);\n\n  /**\n   * 1. make sure we always show at least 8 options to the user\n   * 2. find the default interval closest to the configured minInterval\n   * 3. if we have fewer than 8 options, we basically double the last interval until we have 8 options\n   */\n  const head = DEFAULT_INTERVAL_OPTIONS.filter((millis) => minEvaluationIntervalMillis <= millis);\n\n  const tail = times(MIN_OPTIONS_TO_SHOW - head.length, (index: number) => {\n    const lastInterval = last(head) ?? minEvaluationIntervalMillis;\n    const multiplier = head.length === 0 ? 1 : 2; // if the head is empty we start with the min interval and multiply it only once :)\n    return lastInterval * multiplier * (index + 1);\n  });\n\n  return [...head, ...tail].map(formatPrometheusDuration);\n};\n\nexport const QUICK_PICK_OPTIONS = getEvaluationGroupOptions(MIN_INTERVAl);\n\ninterface Props {\n  currentInterval: string;\n  onSelect: (interval: string) => void;\n}\n\n/**\n * Allow a quick selection of group evaluation intervals, based on the configured \"unifiedAlerting.minInterval\" value\n * ie. [1m, 2m, 5m, 10m, 15m] etc.\n */\nexport const EvaluationGroupQuickPick = ({ currentInterval, onSelect }: Props) => (\n  <Stack direction=\"row\" gap={0.5} role=\"listbox\">\n    {QUICK_PICK_OPTIONS.map((interval) => {\n      const isActive = currentInterval === interval;\n\n      return (\n        <Button\n          role=\"option\"\n          aria-selected={isActive}\n          key={interval}\n          variant={isActive ? 'primary' : 'secondary'}\n          size=\"sm\"\n          onClick={() => onSelect(interval)}\n        >\n          {interval}\n        </Button>\n      );\n    })}\n  </Stack>\n);\n","import { useMemo } from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { Select } from '@grafana/ui';\nimport { SelectBaseProps } from '@grafana/ui/src/components/Select/types';\nimport { GrafanaAlertStateDecision } from 'app/types/unified-alerting-dto';\n\ntype Props = Omit<SelectBaseProps<GrafanaAlertStateDecision>, 'options'> & {\n  includeNoData: boolean;\n  includeError: boolean;\n};\n\nconst options: SelectableValue[] = [\n  { value: GrafanaAlertStateDecision.Alerting, label: 'Alerting' },\n  { value: GrafanaAlertStateDecision.NoData, label: 'No Data' },\n  { value: GrafanaAlertStateDecision.OK, label: 'Normal' },\n  { value: GrafanaAlertStateDecision.Error, label: 'Error' },\n  { value: GrafanaAlertStateDecision.KeepLast, label: 'Keep Last State' },\n];\n\nexport const GrafanaAlertStatePicker = ({ includeNoData, includeError, ...props }: Props) => {\n  const opts = useMemo(() => {\n    if (!includeNoData) {\n      return options.filter((opt) => opt.value !== GrafanaAlertStateDecision.NoData);\n    }\n    if (!includeError) {\n      return options.filter((opt) => opt.value !== GrafanaAlertStateDecision.Error);\n    }\n    return options;\n  }, [includeNoData, includeError]);\n  return <Select options={opts} {...props} />;\n};\n","import { Button, Stack } from '@grafana/ui';\n\nimport { formatPrometheusDuration, safeParsePrometheusDuration } from '../../utils/time';\n\ninterface Props {\n  selectedPendingPeriod: string;\n  groupEvaluationInterval: string;\n  onSelect: (interval: string) => void;\n}\n\nexport function getPendingPeriodQuickOptions(groupEvaluationInterval: string): string[] {\n  const groupEvaluationIntervalMillis = safeParsePrometheusDuration(groupEvaluationInterval);\n\n  // we generate the quick selection based on the group's evaluation interval\n  const options: number[] = [\n    0,\n    groupEvaluationIntervalMillis * 1,\n    groupEvaluationIntervalMillis * 2,\n    groupEvaluationIntervalMillis * 3,\n    groupEvaluationIntervalMillis * 4,\n    groupEvaluationIntervalMillis * 5,\n  ];\n\n  return options.map(formatPrometheusDuration);\n}\n\nexport function PendingPeriodQuickPick({ selectedPendingPeriod, groupEvaluationInterval, onSelect }: Props) {\n  const isQuickSelectionActive = (duration: string) => selectedPendingPeriod === duration;\n\n  const options = getPendingPeriodQuickOptions(groupEvaluationInterval);\n\n  return (\n    <Stack direction=\"row\" gap={0.5} role=\"listbox\">\n      {options.map((duration) => (\n        <Button\n          role=\"option\"\n          aria-selected={isQuickSelectionActive(duration)}\n          key={duration}\n          variant={isQuickSelectionActive(duration) ? 'primary' : 'secondary'}\n          size=\"sm\"\n          onClick={() => {\n            onSelect(duration);\n          }}\n        >\n          {duration === '0s' ? 'None' : duration}\n        </Button>\n      ))}\n    </Stack>\n  );\n}\n","import { css } from '@emotion/css';\nimport { uniqueId } from 'lodash';\nimport { useEffect, useMemo, useState } from 'react';\nimport { Controller, FormProvider, RegisterOptions, useForm, useFormContext } from 'react-hook-form';\n\nimport { GrafanaTheme2, SelectableValue } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport {\n  Box,\n  Button,\n  Field,\n  Icon,\n  Input,\n  Label,\n  Modal,\n  Select,\n  Stack,\n  Switch,\n  Text,\n  Tooltip,\n  useStyles2,\n} from '@grafana/ui';\nimport { Trans, t } from 'app/core/internationalization';\nimport { RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport { alertRuleApi } from '../../api/alertRuleApi';\nimport { GRAFANA_RULER_CONFIG } from '../../api/featureDiscoveryApi';\nimport { DEFAULT_GROUP_EVALUATION_INTERVAL } from '../../rule-editor/formDefaults';\nimport { RuleFormValues } from '../../types/rule-form';\nimport {\n  isGrafanaAlertingRuleByType,\n  isGrafanaManagedRuleByType,\n  isGrafanaRecordingRuleByType,\n  isGrafanaRulerRule,\n} from '../../utils/rules';\nimport { parsePrometheusDuration } from '../../utils/time';\nimport { CollapseToggle } from '../CollapseToggle';\nimport { ProvisioningBadge } from '../Provisioning';\nimport { evaluateEveryValidationOptions } from '../rules/EditRuleGroupModal';\n\nimport { EvaluationGroupQuickPick } from './EvaluationGroupQuickPick';\nimport { GrafanaAlertStatePicker } from './GrafanaAlertStatePicker';\nimport { NeedHelpInfo } from './NeedHelpInfo';\nimport { PendingPeriodQuickPick } from './PendingPeriodQuickPick';\nimport { RuleEditorSection } from './RuleEditorSection';\n\nexport const MIN_TIME_RANGE_STEP_S = 10; // 10 seconds\nexport const MAX_GROUP_RESULTS = 1000;\n\nconst useFetchGroupsForFolder = (folderUid: string) => {\n  // fetch the ruler rules from the database so we can figure out what other \"groups\" are already defined\n  // for our folders\n  return alertRuleApi.endpoints.rulerNamespace.useQuery(\n    {\n      namespace: folderUid,\n      rulerConfig: GRAFANA_RULER_CONFIG,\n    },\n    {\n      refetchOnMountOrArgChange: true,\n      skip: !folderUid,\n    }\n  );\n};\n\nconst namespaceToGroupOptions = (rulerNamespace: RulerRulesConfigDTO, enableProvisionedGroups: boolean) => {\n  const folderGroups = Object.values(rulerNamespace).flat();\n\n  return folderGroups\n    .map<SelectableValue<string>>((group) => {\n      const isProvisioned = isProvisionedGroup(group);\n      return {\n        label: group.name,\n        value: group.name,\n        description: group.interval ?? DEFAULT_GROUP_EVALUATION_INTERVAL,\n        // we include provisioned folders, but disable the option to select them\n        isDisabled: !enableProvisionedGroups ? isProvisioned : false,\n        isProvisioned: isProvisioned,\n      };\n    })\n\n    .sort(sortByLabel);\n};\n\nconst isProvisionedGroup = (group: RulerRuleGroupDTO) => {\n  return group.rules.some((rule) => isGrafanaRulerRule(rule) && Boolean(rule.grafana_alert.provenance) === true);\n};\n\nconst sortByLabel = (a: SelectableValue<string>, b: SelectableValue<string>) => {\n  return a.label?.localeCompare(b.label ?? '') || 0;\n};\n\nconst forValidationOptions = (evaluateEvery: string): RegisterOptions<{ evaluateFor: string }> => ({\n  required: {\n    value: true,\n    message: 'Required.',\n  },\n  validate: (value) => {\n    // parsePrometheusDuration does not allow 0 but does allow 0s\n    if (value === '0') {\n      return true;\n    }\n\n    try {\n      const millisFor = parsePrometheusDuration(value);\n\n      // 0 is a special value meaning for equals evaluation interval\n      if (millisFor === 0) {\n        return true;\n      }\n\n      try {\n        const millisEvery = parsePrometheusDuration(evaluateEvery);\n        return millisFor >= millisEvery\n          ? true\n          : t(\n              'alerting.rule-form.evaluation-behaviour-for.validation',\n              'Pending period must be greater than or equal to the evaluation interval.'\n            );\n      } catch (err) {\n        // if we fail to parse \"every\", assume validation is successful, or the error messages\n        // will overlap in the UI\n        return true;\n      }\n    } catch (error) {\n      return error instanceof Error\n        ? error.message\n        : t('alerting.rule-form.evaluation-behaviour-for.error-parsing', 'Failed to parse duration');\n    }\n  },\n});\n\nexport function GrafanaEvaluationBehaviorStep({\n  existing,\n  enableProvisionedGroups,\n}: {\n  existing: boolean;\n  enableProvisionedGroups: boolean;\n}) {\n  const styles = useStyles2(getStyles);\n  const [showErrorHandling, setShowErrorHandling] = useState(false);\n\n  const {\n    watch,\n    setValue,\n    getValues,\n    formState: { errors },\n    control,\n  } = useFormContext<RuleFormValues>();\n\n  const [group, type, isPaused, folder, evaluateEvery] = watch([\n    'group',\n    'type',\n    'isPaused',\n    'folder',\n    'evaluateEvery',\n  ]);\n\n  const isGrafanaAlertingRule = isGrafanaAlertingRuleByType(type);\n  const isGrafanaRecordingRule = isGrafanaRecordingRuleByType(type);\n  const { currentData: rulerNamespace, isLoading: loadingGroups } = useFetchGroupsForFolder(folder?.uid ?? '');\n\n  const groupOptions = useMemo(() => {\n    return rulerNamespace ? namespaceToGroupOptions(rulerNamespace, enableProvisionedGroups) : [];\n  }, [enableProvisionedGroups, rulerNamespace]);\n\n  const existingGroup = Object.values(rulerNamespace ?? {})\n    .flat()\n    .find((ruleGroup) => ruleGroup.name === group);\n\n  // synchronize the evaluation interval with the group name when it's an existing group\n  useEffect(() => {\n    if (existingGroup) {\n      setValue('evaluateEvery', existingGroup.interval ?? DEFAULT_GROUP_EVALUATION_INTERVAL);\n    }\n  }, [existingGroup, setValue]);\n\n  const [isCreatingEvaluationGroup, setIsCreatingEvaluationGroup] = useState(false);\n\n  const handleEvalGroupCreation = (groupName: string, evaluationInterval: string) => {\n    setValue('group', groupName);\n    setValue('evaluateEvery', evaluationInterval);\n    setIsCreatingEvaluationGroup(false);\n  };\n\n  const defaultGroupValue = group ? { value: group, label: group } : undefined;\n\n  const pauseContentText = isGrafanaRecordingRule\n    ? t('alerting.rule-form.evaluation.pause.recording', 'Turn on to pause evaluation for this recording rule.')\n    : t('alerting.rule-form.evaluation.pause.alerting', 'Turn on to pause evaluation for this alert rule.');\n\n  const onOpenEvaluationGroupCreationModal = () => setIsCreatingEvaluationGroup(true);\n\n  const step = isGrafanaManagedRuleByType(type) ? 4 : 3;\n  const label =\n    isGrafanaManagedRuleByType(type) && !folder?.uid\n      ? t(\n          'alerting.rule-form.evaluation.select-folder-before',\n          'Select a folder before setting evaluation group and interval'\n        )\n      : t('alerting.rule-form.evaluation.evaluation-group-and-interval', 'Evaluation group and interval');\n\n  return (\n    // TODO remove \"and alert condition\" for recording rules\n    <RuleEditorSection\n      stepNo={step}\n      title=\"Set evaluation behavior\"\n      description={getDescription(isGrafanaRecordingRule)}\n    >\n      <Stack direction=\"column\" justify-content=\"flex-start\" align-items=\"flex-start\">\n        <Stack alignItems=\"center\">\n          <div style={{ width: 420 }}>\n            <Field\n              label={label}\n              data-testid=\"group-picker\"\n              className={styles.formInput}\n              error={errors.group?.message}\n              invalid={!!errors.group?.message}\n              htmlFor=\"group\"\n            >\n              <Controller\n                render={({ field: { ref, ...field }, fieldState }) => (\n                  <Select\n                    disabled={!folder?.uid || loadingGroups}\n                    inputId=\"group\"\n                    key={uniqueId()}\n                    {...field}\n                    onChange={(group) => {\n                      field.onChange(group.label ?? '');\n                    }}\n                    isLoading={loadingGroups}\n                    invalid={Boolean(folder?.uid) && !group && Boolean(fieldState.error)}\n                    cacheOptions\n                    loadingMessage={'Loading groups...'}\n                    defaultValue={defaultGroupValue}\n                    options={groupOptions}\n                    getOptionLabel={(option: SelectableValue<string>) => (\n                      <div>\n                        <span>{option.label}</span>\n                        {option.isProvisioned && (\n                          <>\n                            {' '}\n                            <ProvisioningBadge />\n                          </>\n                        )}\n                      </div>\n                    )}\n                    placeholder={'Select an evaluation group...'}\n                  />\n                )}\n                name=\"group\"\n                control={control}\n                rules={{\n                  required: { value: true, message: 'Must enter a group name' },\n                }}\n              />\n            </Field>\n          </div>\n          <Box gap={1} display={'flex'} alignItems={'center'}>\n            <Text color=\"secondary\">or</Text>\n            <Button\n              onClick={onOpenEvaluationGroupCreationModal}\n              type=\"button\"\n              icon=\"plus\"\n              fill=\"outline\"\n              variant=\"secondary\"\n              disabled={!folder?.uid}\n              data-testid={selectors.components.AlertRules.newEvaluationGroupButton}\n            >\n              <Trans i18nKey=\"alerting.rule-form.evaluation.new-group\">New evaluation group</Trans>\n            </Button>\n          </Box>\n          {isCreatingEvaluationGroup && (\n            <EvaluationGroupCreationModal\n              onCreate={handleEvalGroupCreation}\n              onClose={() => setIsCreatingEvaluationGroup(false)}\n              groupfoldersForGrafana={rulerNamespace}\n            />\n          )}\n        </Stack>\n\n        {folder?.title && group && (\n          <div className={styles.evaluationContainer}>\n            <Stack direction=\"column\" gap={0}>\n              <div className={styles.marginTop}>\n                <Stack direction=\"column\" gap={1}>\n                  {getValues('group') && getValues('evaluateEvery') && (\n                    <Trans i18nKey=\"alerting.rule-form.evaluation.group-text\" values={{ evaluateEvery }}>\n                      All rules in the selected group are evaluated every {{ evaluateEvery }}.\n                    </Trans>\n                  )}\n                </Stack>\n              </div>\n            </Stack>\n          </div>\n        )}\n        {/* Show the pending period input only for Grafana alerting rules */}\n        {isGrafanaAlertingRule && <ForInput evaluateEvery={evaluateEvery} />}\n\n        {existing && (\n          <Field htmlFor=\"pause-alert-switch\">\n            <Controller\n              render={() => (\n                <Stack gap={1} direction=\"row\" alignItems=\"center\">\n                  <Switch\n                    id=\"pause-alert\"\n                    onChange={(value) => {\n                      setValue('isPaused', value.currentTarget.checked);\n                    }}\n                    value={Boolean(isPaused)}\n                  />\n                  <label htmlFor=\"pause-alert\" className={styles.switchLabel}>\n                    <Trans i18nKey=\"alerting.rule-form.pause.label\">Pause evaluation</Trans>\n                    <Tooltip placement=\"top\" content={pauseContentText} theme={'info'}>\n                      <Icon tabIndex={0} name=\"info-circle\" size=\"sm\" className={styles.infoIcon} />\n                    </Tooltip>\n                  </label>\n                </Stack>\n              )}\n              name=\"isPaused\"\n            />\n          </Field>\n        )}\n      </Stack>\n      {isGrafanaAlertingRule && (\n        <>\n          <CollapseToggle\n            isCollapsed={!showErrorHandling}\n            onToggle={(collapsed) => setShowErrorHandling(!collapsed)}\n            text=\"Configure no data and error handling\"\n          />\n          {showErrorHandling && (\n            <>\n              <NeedHelpInfoForConfigureNoDataError />\n              <Field\n                htmlFor=\"no-data-state-input\"\n                label={t('alerting.alert.state-no-data', 'Alert state if no data or all values are null')}\n              >\n                <Controller\n                  render={({ field: { onChange, ref, ...field } }) => (\n                    <GrafanaAlertStatePicker\n                      {...field}\n                      inputId=\"no-data-state-input\"\n                      width={42}\n                      includeNoData={true}\n                      includeError={false}\n                      onChange={(value) => onChange(value?.value)}\n                    />\n                  )}\n                  name=\"noDataState\"\n                />\n              </Field>\n              <Field\n                htmlFor=\"exec-err-state-input\"\n                label={t('alerting.alert.state-error-timeout', 'Alert state if execution error or timeout')}\n              >\n                <Controller\n                  render={({ field: { onChange, ref, ...field } }) => (\n                    <GrafanaAlertStatePicker\n                      {...field}\n                      inputId=\"exec-err-state-input\"\n                      width={42}\n                      includeNoData={false}\n                      includeError={true}\n                      onChange={(value) => onChange(value?.value)}\n                    />\n                  )}\n                  name=\"execErrState\"\n                />\n              </Field>\n            </>\n          )}\n        </>\n      )}\n    </RuleEditorSection>\n  );\n}\n\nfunction EvaluationGroupCreationModal({\n  onClose,\n  onCreate,\n  groupfoldersForGrafana,\n}: {\n  onClose: () => void;\n  onCreate: (group: string, evaluationInterval: string) => void;\n  groupfoldersForGrafana?: RulerRulesConfigDTO | null;\n}): React.ReactElement {\n  const styles = useStyles2(getStyles);\n  const { watch } = useFormContext<RuleFormValues>();\n\n  const evaluateEveryId = 'eval-every-input';\n  const evaluationGroupNameId = 'new-eval-group-name';\n  const [groupName, folderName, type] = watch(['group', 'folder.title', 'type']);\n  const isGrafanaRecordingRule = type ? isGrafanaRecordingRuleByType(type) : false;\n\n  const formAPI = useForm({\n    defaultValues: { group: '', evaluateEvery: DEFAULT_GROUP_EVALUATION_INTERVAL },\n    mode: 'onChange',\n    shouldFocusError: true,\n  });\n\n  const { register, handleSubmit, formState, setValue, getValues, watch: watchGroupFormValues } = formAPI;\n  const evaluationInterval = watchGroupFormValues('evaluateEvery');\n\n  const groupRules =\n    (groupfoldersForGrafana && groupfoldersForGrafana[folderName]?.find((g) => g.name === groupName)?.rules) ?? [];\n\n  const onSubmit = () => {\n    onCreate(getValues('group'), getValues('evaluateEvery'));\n  };\n\n  const onCancel = () => {\n    onClose();\n  };\n\n  const setEvaluationInterval = (interval: string) => {\n    setValue('evaluateEvery', interval, { shouldValidate: true });\n  };\n\n  const modalTitle = isGrafanaRecordingRule\n    ? t(\n        'alerting.folderAndGroup.evaluation.modal.text.recording',\n        'Create a new evaluation group to use for this recording rule.'\n      )\n    : t(\n        'alerting.folderAndGroup.evaluation.modal.text.alerting',\n        'Create a new evaluation group to use for this alert rule.'\n      );\n\n  return (\n    <Modal\n      className={styles.modal}\n      isOpen={true}\n      title={'New evaluation group'}\n      onDismiss={onCancel}\n      onClickBackdrop={onCancel}\n    >\n      <div className={styles.modalTitle}>{modalTitle}</div>\n\n      <FormProvider {...formAPI}>\n        <form onSubmit={handleSubmit(() => onSubmit())}>\n          <Field\n            label={\n              <Label\n                htmlFor={evaluationGroupNameId}\n                description=\"A group evaluates all its rules over the same evaluation interval.\"\n              >\n                <Trans i18nKey=\"alerting.rule-form.evaluation.group-name\">Evaluation group name</Trans>\n              </Label>\n            }\n            error={formState.errors.group?.message}\n            invalid={Boolean(formState.errors.group)}\n          >\n            <Input\n              data-testid={selectors.components.AlertRules.newEvaluationGroupName}\n              className={styles.formInput}\n              autoFocus={true}\n              id={evaluationGroupNameId}\n              placeholder=\"Enter a name\"\n              {...register('group', { required: { value: true, message: 'Required.' } })}\n            />\n          </Field>\n\n          <Field\n            error={formState.errors.evaluateEvery?.message}\n            label={\n              <Label htmlFor={evaluateEveryId} description=\"How often all rules in the group are evaluated.\">\n                <Trans i18nKey=\"alerting.rule-form.evaluation.group.interval\">Evaluation interval</Trans>\n              </Label>\n            }\n            invalid={Boolean(formState.errors.evaluateEvery)}\n          >\n            <Input\n              data-testid={selectors.components.AlertRules.newEvaluationGroupInterval}\n              className={styles.formInput}\n              id={evaluateEveryId}\n              placeholder={DEFAULT_GROUP_EVALUATION_INTERVAL}\n              {...register(\n                'evaluateEvery',\n                evaluateEveryValidationOptions<{ group: string; evaluateEvery: string }>(groupRules)\n              )}\n            />\n          </Field>\n\n          <EvaluationGroupQuickPick currentInterval={evaluationInterval} onSelect={setEvaluationInterval} />\n\n          <Modal.ButtonRow>\n            <Button variant=\"secondary\" type=\"button\" onClick={onCancel}>\n              <Trans i18nKey=\"alerting.rule-form.evaluation.group.cancel\">Cancel</Trans>\n            </Button>\n            <Button\n              type=\"submit\"\n              disabled={!formState.isValid}\n              data-testid={selectors.components.AlertRules.newEvaluationGroupCreate}\n            >\n              <Trans i18nKey=\"alerting.rule-form.evaluation.group.create\">Create</Trans>\n            </Button>\n          </Modal.ButtonRow>\n        </form>\n      </FormProvider>\n    </Modal>\n  );\n}\n\nexport function ForInput({ evaluateEvery }: { evaluateEvery: string }) {\n  const styles = useStyles2(getStyles);\n  const {\n    register,\n    formState: { errors },\n    setValue,\n    watch,\n  } = useFormContext<RuleFormValues>();\n\n  const evaluateForId = 'eval-for-input';\n  const currentPendingPeriod = watch('evaluateFor');\n\n  const setPendingPeriod = (pendingPeriod: string) => {\n    setValue('evaluateFor', pendingPeriod);\n  };\n\n  return (\n    <Stack direction=\"column\" justify-content=\"flex-start\" align-items=\"flex-start\">\n      <Field\n        label={\n          <Label\n            htmlFor={evaluateForId}\n            description='Period during which the threshold condition must be met to trigger an alert. Selecting \"None\" triggers the alert immediately once the condition is met.'\n          >\n            <Trans i18nKey=\"alerting.rule-form.evaluation-behaviour.pending-period\">Pending period</Trans>\n          </Label>\n        }\n        className={styles.inlineField}\n        error={errors.evaluateFor?.message}\n        invalid={Boolean(errors.evaluateFor?.message) ? true : undefined}\n        validationMessageHorizontalOverflow={true}\n      >\n        <Input id={evaluateForId} width={8} {...register('evaluateFor', forValidationOptions(evaluateEvery))} />\n      </Field>\n      <PendingPeriodQuickPick\n        selectedPendingPeriod={currentPendingPeriod}\n        groupEvaluationInterval={evaluateEvery}\n        onSelect={setPendingPeriod}\n      />\n    </Stack>\n  );\n}\n\nfunction NeedHelpInfoForConfigureNoDataError() {\n  const docsLink =\n    'https://grafana.com/docs/grafana/latest/alerting/alerting-rules/create-grafana-managed-rule/#configure-no-data-and-error-handling';\n\n  return (\n    <Stack direction=\"row\" gap={0.5} alignItems=\"center\">\n      <Text variant=\"bodySmall\" color=\"secondary\">\n        <Trans i18nKey=\"alerting.rule-form.evaluation-behaviour.info-help.text\">\n          Define the alert behavior when the evaluation fails or the query returns no data.\n        </Trans>\n      </Text>\n      <NeedHelpInfo\n        contentText=\"These settings can help mitigate temporary data source issues, preventing alerts from unintentionally firing due to lack of data, errors, or timeouts.\"\n        externalLink={docsLink}\n        linkText={`Read more about this option`}\n        title=\"Configure no data and error handling\"\n      />\n    </Stack>\n  );\n}\n\nfunction getDescription(isGrafanaRecordingRule: boolean) {\n  const docsLink = 'https://grafana.com/docs/grafana/latest/alerting/fundamentals/alert-rules/rule-evaluation/';\n\n  return (\n    <Stack direction=\"row\" gap={0.5} alignItems=\"center\">\n      <Text variant=\"bodySmall\" color=\"secondary\">\n        {isGrafanaRecordingRule ? (\n          <Trans i18nKey=\"alerting.alert-recording-rule-form.evaluation-behaviour.description.text\">\n            Define how the recording rule is evaluated.\n          </Trans>\n        ) : (\n          <Trans i18nKey=\"alerting.rule-form.evaluation-behaviour.description.text\">\n            Define how the alert rule is evaluated.\n          </Trans>\n        )}\n      </Text>\n      <NeedHelpInfo\n        contentText={\n          <>\n            <p>\n              <Trans i18nKey=\"alerting.rule-form.evaluation-behaviour-description1\">\n                Evaluation groups are containers for evaluating alert and recording rules.\n              </Trans>\n            </p>\n            <p>\n              <Trans i18nKey=\"alerting.rule-form.evaluation-behaviour-description2\">\n                An evaluation group defines an evaluation interval - how often a rule is evaluated. Alert rules within\n                the same evaluation group are evaluated over the same evaluation interval.\n              </Trans>\n            </p>\n            <p>\n              <Trans i18nKey=\"alerting.rule-form.evaluation-behaviour-description3\">\n                Pending period specifies how long the threshold condition must be met before the alert starts firing.\n                This option helps prevent alerts from being triggered by temporary issues.\n              </Trans>\n            </p>\n          </>\n        }\n        externalLink={docsLink}\n        linkText={`Read about evaluation and alert states`}\n        title=\"Alert rule evaluation\"\n      />\n    </Stack>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  inlineField: css({\n    marginBottom: 0,\n  }),\n  evaluationContainer: css({\n    color: theme.colors.text.secondary,\n    maxWidth: `${theme.breakpoints.values.sm}px`,\n    fontSize: theme.typography.size.sm,\n  }),\n  infoIcon: css({\n    marginLeft: '10px',\n  }),\n  marginTop: css({\n    marginTop: theme.spacing(1),\n  }),\n  switchLabel: css({\n    color: theme.colors.text.primary,\n    cursor: 'pointer',\n    fontSize: theme.typography.bodySmall.fontSize,\n  }),\n  formInput: css({\n    flexGrow: 1,\n  }),\n  modal: css({\n    width: `${theme.breakpoints.values.sm}px`,\n  }),\n  modalTitle: css({\n    color: theme.colors.text.secondary,\n    marginBottom: theme.spacing(2),\n  }),\n});\n","import { config } from '@grafana/runtime';\nimport { Alert } from '@grafana/ui';\n\nconst EvaluationIntervalLimitExceeded = () => (\n  <Alert severity=\"warning\" title=\"Global evaluation interval limit exceeded\">\n    A minimum evaluation interval of <strong>{config.unifiedAlerting.minInterval}</strong> has been configured in\n    Grafana.\n    <br />\n    Please contact the administrator to configure a lower interval.\n  </Alert>\n);\n\nexport { EvaluationIntervalLimitExceeded };\n","import { css } from '@emotion/css';\nimport { compact } from 'lodash';\nimport { useMemo } from 'react';\nimport { FieldValues, FormProvider, RegisterOptions, useForm, useFormContext } from 'react-hook-form';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport {\n  Alert,\n  Badge,\n  Button,\n  Field,\n  Input,\n  Label,\n  LinkButton,\n  LoadingPlaceholder,\n  Modal,\n  Stack,\n  useStyles2,\n} from '@grafana/ui';\nimport { useAppNotification } from 'app/core/copy/appNotification';\nimport { Trans, t } from 'app/core/internationalization';\nimport { dispatch } from 'app/store/store';\nimport { RuleGroupIdentifier, RulerDataSourceConfig } from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO } from 'app/types/unified-alerting-dto';\n\nimport { alertRuleApi } from '../../api/alertRuleApi';\nimport {\n  useMoveRuleGroup,\n  useRenameRuleGroup,\n  useUpdateRuleGroupConfiguration,\n} from '../../hooks/ruleGroup/useUpdateRuleGroup';\nimport { anyOfRequestState } from '../../hooks/useAsync';\nimport { DEFAULT_GROUP_EVALUATION_INTERVAL } from '../../rule-editor/formDefaults';\nimport { fetchRulerRulesAction, rulesInSameGroupHaveInvalidFor } from '../../state/actions';\nimport { checkEvaluationIntervalGlobalLimit } from '../../utils/config';\nimport { GRAFANA_RULES_SOURCE_NAME } from '../../utils/datasource';\nimport { stringifyErrorLike } from '../../utils/misc';\nimport { AlertInfo, getAlertInfo, isGrafanaOrDataSourceRecordingRule } from '../../utils/rules';\nimport { formatPrometheusDuration, parsePrometheusDuration, safeParsePrometheusDuration } from '../../utils/time';\nimport { DynamicTable, DynamicTableColumnProps, DynamicTableItemProps } from '../DynamicTable';\nimport { EvaluationIntervalLimitExceeded } from '../InvalidIntervalWarning';\nimport { EvaluationGroupQuickPick } from '../rule-editor/EvaluationGroupQuickPick';\nimport { MIN_TIME_RANGE_STEP_S } from '../rule-editor/GrafanaEvaluationBehavior';\n\nconst useRuleGroupDefinition = alertRuleApi.endpoints.getRuleGroupForNamespace.useQuery;\n\nconst ITEMS_PER_PAGE = 10;\n\nfunction ForBadge({ message, error }: { message: string; error?: boolean }) {\n  if (error) {\n    return <Badge color=\"red\" icon=\"exclamation-circle\" text={'Error'} tooltip={message} />;\n  } else {\n    return <Badge color=\"orange\" icon=\"exclamation-triangle\" text={'Unknown'} tooltip={message} />;\n  }\n}\n\nconst isValidEvaluation = (evaluation: string) => {\n  try {\n    const duration = parsePrometheusDuration(evaluation);\n\n    if (duration < MIN_TIME_RANGE_STEP_S * 1000) {\n      return false;\n    }\n\n    if (duration % (MIN_TIME_RANGE_STEP_S * 1000) !== 0) {\n      return false;\n    }\n\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\ntype AlertsWithForTableColumnProps = DynamicTableColumnProps<AlertInfo>;\ntype AlertsWithForTableProps = DynamicTableItemProps<AlertInfo>;\n\nexport const RulesForGroupTable = ({ rulesWithoutRecordingRules }: { rulesWithoutRecordingRules: RulerRuleDTO[] }) => {\n  const styles = useStyles2(getStyles);\n\n  const { watch } = useFormContext<FormValues>();\n  const currentInterval = watch('groupInterval');\n  const unknownCurrentInterval = !Boolean(currentInterval);\n\n  const rows: AlertsWithForTableProps[] = rulesWithoutRecordingRules\n    .slice()\n    .map((rule: RulerRuleDTO, index) => ({\n      id: index,\n      data: getAlertInfo(rule, currentInterval),\n    }))\n    .sort(\n      (alert1, alert2) =>\n        safeParsePrometheusDuration(alert1.data.forDuration ?? '') -\n        safeParsePrometheusDuration(alert2.data.forDuration ?? '')\n    );\n\n  const columns: AlertsWithForTableColumnProps[] = useMemo(() => {\n    return [\n      {\n        id: 'alertName',\n        label: 'Alert',\n        renderCell: ({ data: { alertName } }) => {\n          return <>{alertName}</>;\n        },\n        size: '330px',\n      },\n      {\n        id: 'for',\n        label: 'Pending period',\n        renderCell: ({ data: { forDuration } }) => {\n          return <>{forDuration}</>;\n        },\n        size: 0.5,\n      },\n      {\n        id: 'numberEvaluations',\n        label: '#Eval',\n        renderCell: ({ data: { evaluationsToFire: numberEvaluations } }) => {\n          if (unknownCurrentInterval) {\n            return <ForBadge message=\"#Evaluations not available.\" />;\n          } else {\n            if (!isValidEvaluation(currentInterval)) {\n              return <ForBadge message={'Invalid evaluation interval format'} error />;\n            }\n            if (numberEvaluations === 0) {\n              return (\n                <ForBadge message=\"Invalid 'For' value: it should be greater or equal to evaluation interval.\" error />\n              );\n            } else {\n              return <>{numberEvaluations}</>;\n            }\n          }\n        },\n        size: 0.4,\n      },\n    ];\n  }, [currentInterval, unknownCurrentInterval]);\n\n  return (\n    <div className={styles.tableWrapper}>\n      <DynamicTable items={rows} cols={columns} pagination={{ itemsPerPage: ITEMS_PER_PAGE }} />\n    </div>\n  );\n};\n\ninterface FormValues {\n  namespaceName: string;\n  groupName: string;\n  groupInterval: string;\n}\n\nexport const evaluateEveryValidationOptions = <T extends FieldValues>(rules: RulerRuleDTO[]): RegisterOptions<T> => ({\n  required: {\n    value: true,\n    message: 'Required.',\n  },\n  validate: (evaluateEvery: string) => {\n    try {\n      const duration = parsePrometheusDuration(evaluateEvery);\n\n      if (duration < MIN_TIME_RANGE_STEP_S * 1000) {\n        return `Cannot be less than ${MIN_TIME_RANGE_STEP_S} seconds.`;\n      }\n\n      if (duration % (MIN_TIME_RANGE_STEP_S * 1000) !== 0) {\n        return `Must be a multiple of ${MIN_TIME_RANGE_STEP_S} seconds.`;\n      }\n      if (rulesInSameGroupHaveInvalidFor(rules, evaluateEvery).length === 0) {\n        return true;\n      } else {\n        const rulePendingPeriods = rules.map((rule) => {\n          const { forDuration } = getAlertInfo(rule, evaluateEvery);\n          return forDuration ? safeParsePrometheusDuration(forDuration) : null;\n        });\n        const largestPendingPeriod = Math.min(\n          ...rulePendingPeriods.filter((period): period is number => period !== null)\n        );\n        return `Evaluation interval should be smaller or equal to \"pending period\" values for existing rules in this rule group. Choose a value smaller than or equal to \"${formatPrometheusDuration(largestPendingPeriod)}\".`;\n      }\n    } catch (error) {\n      return error instanceof Error ? error.message : 'Failed to parse duration';\n    }\n  },\n});\n\nexport interface ModalProps {\n  ruleGroupIdentifier: RuleGroupIdentifier;\n  folderTitle?: string;\n  rulerConfig: RulerDataSourceConfig;\n  onClose: (saved?: boolean) => void;\n  intervalEditOnly?: boolean;\n  folderUrl?: string;\n  hideFolder?: boolean;\n}\n\nexport interface ModalFormProps {\n  ruleGroupIdentifier: RuleGroupIdentifier;\n  folderTitle?: string; // used to display the GMA folder title\n  ruleGroup: RulerRuleGroupDTO;\n  onClose: (saved?: boolean) => void;\n  intervalEditOnly?: boolean;\n  folderUrl?: string;\n  hideFolder?: boolean;\n}\n\n// this component just wraps the modal with some loading state for grabbing rules and such\nexport function EditRuleGroupModal(props: ModalProps) {\n  const { ruleGroupIdentifier, rulerConfig, intervalEditOnly, onClose } = props;\n  const rulesSourceName = ruleGroupIdentifier.dataSourceName;\n  const isGrafanaManagedGroup = rulesSourceName === GRAFANA_RULES_SOURCE_NAME;\n\n  const modalTitle =\n    intervalEditOnly || isGrafanaManagedGroup ? 'Edit evaluation group' : 'Edit namespace or evaluation group';\n\n  const styles = useStyles2(getStyles);\n\n  const {\n    data: ruleGroup,\n    error,\n    isLoading,\n  } = useRuleGroupDefinition({\n    group: ruleGroupIdentifier.groupName,\n    namespace: ruleGroupIdentifier.namespaceName,\n    rulerConfig,\n  });\n\n  const loadingText = t('alerting.common.loading', 'Loading...');\n\n  return (\n    <Modal className={styles.modal} isOpen={true} title={modalTitle} onDismiss={onClose} onClickBackdrop={onClose}>\n      {isLoading && <LoadingPlaceholder text={loadingText} />}\n      {error ? stringifyErrorLike(error) : null}\n      {ruleGroup && <EditRuleGroupModalForm {...props} ruleGroup={ruleGroup} />}\n    </Modal>\n  );\n}\n\nexport function EditRuleGroupModalForm(props: ModalFormProps): React.ReactElement {\n  const { ruleGroup, ruleGroupIdentifier, folderTitle, onClose, intervalEditOnly } = props;\n\n  const styles = useStyles2(getStyles);\n  const notifyApp = useAppNotification();\n\n  /**\n   * This modal can take 3 different actions, depending on what fields were updated.\n   *\n   *  1. update the rule group details without renaming either the namespace or group\n   *  2. rename the rule group, but keeping it in the same namespace\n   *  3. move the rule group to a new namespace, optionally with a different group name\n   */\n  const [updateRuleGroup, updateRuleGroupState] = useUpdateRuleGroupConfiguration();\n  const [renameRuleGroup, renameRuleGroupState] = useRenameRuleGroup();\n  const [moveRuleGroup, moveRuleGroupState] = useMoveRuleGroup();\n\n  const { loading, error } = anyOfRequestState(updateRuleGroupState, moveRuleGroupState, renameRuleGroupState);\n\n  const defaultValues = useMemo(\n    (): FormValues => ({\n      namespaceName: ruleGroupIdentifier.namespaceName,\n      groupName: ruleGroupIdentifier.groupName,\n      groupInterval: ruleGroup?.interval ?? DEFAULT_GROUP_EVALUATION_INTERVAL,\n    }),\n    [ruleGroup?.interval, ruleGroupIdentifier.groupName, ruleGroupIdentifier.namespaceName]\n  );\n\n  const rulesSourceName = ruleGroupIdentifier.dataSourceName;\n  const isGrafanaManagedGroup = rulesSourceName === GRAFANA_RULES_SOURCE_NAME;\n\n  const nameSpaceLabel = isGrafanaManagedGroup ? 'Folder' : 'Namespace';\n\n  const onSubmit = async (values: FormValues) => {\n    // make sure that when dealing with a nested folder for Grafana managed rules we encode the folder properly\n    const updatedNamespaceName = values.namespaceName;\n    const updatedGroupName = values.groupName;\n    const updatedInterval = values.groupInterval;\n\n    // GMA alert rules cannot be moved to another folder, we currently do not support it but it should be doable (with caveats).\n    const shouldMove = isGrafanaManagedGroup ? false : updatedNamespaceName !== ruleGroupIdentifier.namespaceName;\n    const shouldRename = updatedGroupName !== ruleGroupIdentifier.groupName;\n\n    try {\n      if (shouldMove) {\n        await moveRuleGroup.execute(ruleGroupIdentifier, updatedNamespaceName, updatedGroupName, updatedInterval);\n      } else if (shouldRename) {\n        await renameRuleGroup.execute(ruleGroupIdentifier, updatedGroupName, updatedInterval);\n      } else {\n        await updateRuleGroup.execute(ruleGroupIdentifier, updatedInterval);\n      }\n      onClose(true);\n      await dispatch(fetchRulerRulesAction({ rulesSourceName }));\n    } catch (_error) {} // React hook form will handle errors\n  };\n\n  const formAPI = useForm<FormValues>({\n    mode: 'onBlur',\n    defaultValues,\n    shouldFocusError: true,\n  });\n\n  const {\n    handleSubmit,\n    register,\n    watch,\n    formState: { isDirty, errors, isValid },\n    setValue,\n    getValues,\n  } = formAPI;\n\n  const onInvalid = () => {\n    notifyApp.error('There are errors in the form. Correct the errors and retry.');\n  };\n\n  const rulesWithoutRecordingRules = compact(\n    ruleGroup?.rules.filter((rule) => !isGrafanaOrDataSourceRecordingRule(rule))\n  );\n  const hasSomeNoRecordingRules = rulesWithoutRecordingRules.length > 0;\n\n  return (\n    <FormProvider {...formAPI}>\n      <form onSubmit={handleSubmit(onSubmit, onInvalid)} key={JSON.stringify(defaultValues)}>\n        <>\n          {!props.hideFolder && (\n            <Stack gap={1} alignItems={'center'}>\n              <Field\n                className={styles.formInput}\n                label={\n                  <Label\n                    htmlFor=\"namespaceName\"\n                    description={\n                      !isGrafanaManagedGroup &&\n                      'Change the current namespace name. Moving groups between namespaces is not supported'\n                    }\n                  >\n                    {nameSpaceLabel}\n                  </Label>\n                }\n                invalid={Boolean(errors.namespaceName) ? true : undefined}\n                error={errors.namespaceName?.message}\n              >\n                <Input\n                  id=\"namespaceName\"\n                  readOnly={intervalEditOnly || isGrafanaManagedGroup}\n                  value={folderTitle}\n                  {...register('namespaceName', {\n                    required: 'Namespace name is required.',\n                  })}\n                />\n              </Field>\n              {isGrafanaManagedGroup && props.folderUrl && (\n                <LinkButton\n                  href={props.folderUrl}\n                  title=\"Go to folder\"\n                  variant=\"secondary\"\n                  icon=\"folder-open\"\n                  target=\"_blank\"\n                />\n              )}\n            </Stack>\n          )}\n          <Field\n            label={\n              <Label\n                htmlFor=\"groupName\"\n                description=\"A group evaluates all its rules over the same evaluation interval.\"\n              >\n                Evaluation group\n              </Label>\n            }\n            invalid={!!errors.groupName}\n            error={errors.groupName?.message}\n          >\n            <Input\n              autoFocus={true}\n              id=\"groupName\"\n              readOnly={intervalEditOnly}\n              {...register('groupName', {\n                required: 'Evaluation group name is required.',\n              })}\n            />\n          </Field>\n          <Field\n            label={\n              <Label\n                htmlFor=\"groupInterval\"\n                description=\"How often is the rule evaluated. Applies to every rule within the group.\"\n              >\n                <Stack gap={0.5}>Evaluation interval</Stack>\n              </Label>\n            }\n            invalid={Boolean(errors.groupInterval) ? true : undefined}\n            error={errors.groupInterval?.message}\n          >\n            <Stack direction=\"column\">\n              <Input\n                id=\"groupInterval\"\n                placeholder={DEFAULT_GROUP_EVALUATION_INTERVAL}\n                {...register('groupInterval', evaluateEveryValidationOptions(rulesWithoutRecordingRules))}\n              />\n              <EvaluationGroupQuickPick\n                currentInterval={getValues('groupInterval')}\n                onSelect={(value) => setValue('groupInterval', value, { shouldValidate: true, shouldDirty: true })}\n              />\n            </Stack>\n          </Field>\n\n          {/* if we're dealing with a Grafana-managed group, check if the evaluation interval is valid / permitted */}\n          {isGrafanaManagedGroup && checkEvaluationIntervalGlobalLimit(watch('groupInterval')).exceedsLimit && (\n            <EvaluationIntervalLimitExceeded />\n          )}\n\n          {!hasSomeNoRecordingRules && <div>This group does not contain alert rules.</div>}\n          {hasSomeNoRecordingRules && (\n            <>\n              <div>List of rules that belong to this group</div>\n              <div className={styles.evalRequiredLabel}>\n                #Eval column represents the number of evaluations needed before alert starts firing.\n              </div>\n              <RulesForGroupTable rulesWithoutRecordingRules={rulesWithoutRecordingRules} />\n            </>\n          )}\n          {error && <Alert title={'Failed to update rule group'}>{stringifyErrorLike(error)}</Alert>}\n          <div className={styles.modalButtons}>\n            <Modal.ButtonRow>\n              <Button\n                variant=\"secondary\"\n                type=\"button\"\n                disabled={loading}\n                onClick={() => onClose(false)}\n                fill=\"outline\"\n              >\n                <Trans i18nKey=\"alerting.common.cancel\">Cancel</Trans>\n              </Button>\n              <Button type=\"submit\" disabled={!isDirty || !isValid || loading}>\n                {loading ? 'Saving...' : 'Save'}\n              </Button>\n            </Modal.ButtonRow>\n          </div>\n        </>\n      </form>\n    </FormProvider>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  modal: css({\n    maxWidth: '560px',\n  }),\n  modalButtons: css({\n    top: '-24px',\n    position: 'relative',\n  }),\n  formInput: css({\n    flex: 1,\n  }),\n  tableWrapper: css({\n    marginTop: theme.spacing(2),\n    marginBottom: theme.spacing(2),\n    height: '100%',\n  }),\n  evalRequiredLabel: css({\n    fontSize: theme.typography.bodySmall.fontSize,\n  }),\n});\n","import { t } from 'app/core/internationalization';\nimport { RuleGroupIdentifier } from 'app/types/unified-alerting';\n\nimport { alertRuleApi } from '../../api/alertRuleApi';\nimport { notFoundToNullOrThrow } from '../../api/util';\nimport {\n  moveRuleGroupAction,\n  renameRuleGroupAction,\n  reorderRulesInRuleGroupAction,\n  updateRuleGroupAction,\n} from '../../reducers/ruler/ruleGroups';\nimport { isGrafanaRulesSource } from '../../utils/datasource';\nimport { useAsync } from '../useAsync';\n\nimport { useProduceNewRuleGroup } from './useProduceNewRuleGroup';\n\nconst ruleUpdateSuccessMessage = () => t('alerting.rule-groups.update.success', 'Successfully updated rule group');\n\n/**\n * Update an existing rule group, currently only supports updating the interval.\n * Use \"useRenameRuleGroup\" or \"useMoveRuleGroup\" for updating the namespace or group name.\n */\nexport function useUpdateRuleGroupConfiguration() {\n  const [produceNewRuleGroup] = useProduceNewRuleGroup();\n  const [upsertRuleGroup] = alertRuleApi.endpoints.upsertRuleGroupForNamespace.useMutation();\n\n  return useAsync(async (ruleGroup: RuleGroupIdentifier, interval: string) => {\n    const { namespaceName } = ruleGroup;\n\n    const action = updateRuleGroupAction({ interval });\n    const { newRuleGroupDefinition, rulerConfig } = await produceNewRuleGroup(ruleGroup, action);\n\n    return upsertRuleGroup({\n      rulerConfig,\n      namespace: namespaceName,\n      payload: newRuleGroupDefinition,\n      notificationOptions: { successMessage: ruleUpdateSuccessMessage() },\n    }).unwrap();\n  });\n}\n\n/**\n * Move a rule group to either another namespace with (optionally) a different name, throws if the action\n * targets an existing rule group.\n * Optionally, update the rule group evaluation interval.\n */\nexport function useMoveRuleGroup() {\n  const [produceNewRuleGroup] = useProduceNewRuleGroup();\n  const [fetchRuleGroup] = alertRuleApi.endpoints.getRuleGroupForNamespace.useLazyQuery();\n  const [upsertRuleGroup] = alertRuleApi.endpoints.upsertRuleGroupForNamespace.useMutation();\n  const [deleteRuleGroup] = alertRuleApi.endpoints.deleteRuleGroupFromNamespace.useMutation();\n\n  // @TODO maybe add where we moved it from and to for additional peace of mind\n  const successMessage = t('alerting.rule-groups.move.success', 'Successfully moved rule group');\n\n  return useAsync(\n    async (ruleGroup: RuleGroupIdentifier, namespaceName: string, groupName?: string, interval?: string) => {\n      // we could technically support moving rule groups to another folder, though we don't have a \"move\" wizard yet.\n      if (isGrafanaRulesSource(ruleGroup.dataSourceName)) {\n        throw new Error('Moving a Grafana-managed rule group to another folder is currently not supported.');\n      }\n\n      const action = moveRuleGroupAction({ newNamespaceName: namespaceName, groupName, interval });\n      const { newRuleGroupDefinition, rulerConfig } = await produceNewRuleGroup(ruleGroup, action);\n\n      const oldNamespace = ruleGroup.namespaceName;\n      const targetNamespace = action.payload.newNamespaceName;\n\n      const oldGroupName = ruleGroup.groupName;\n      const targetGroupName = action.payload.groupName;\n\n      const isGroupRenamed = Boolean(targetGroupName) && oldGroupName !== targetGroupName;\n\n      // if we're also renaming the group, check if the target does not already exist\n      if (targetGroupName && isGroupRenamed) {\n        const targetGroup = await fetchRuleGroup({\n          rulerConfig,\n          namespace: targetNamespace,\n          group: targetGroupName,\n          // since this could throw 404\n          notificationOptions: { showErrorAlert: false },\n        })\n          .unwrap()\n          .catch(notFoundToNullOrThrow);\n\n        if (targetGroup?.rules?.length) {\n          throw new Error('Target group already has rules, merging rule groups is currently not supported.');\n        }\n      }\n\n      // create the new group in the target namespace\n      // ⚠️ it's important to do this before we remove the old group – better to have two groups than none if one of these requests fails\n      await upsertRuleGroup({\n        rulerConfig,\n        namespace: targetNamespace,\n        payload: newRuleGroupDefinition,\n        notificationOptions: { successMessage },\n      }).unwrap();\n\n      // now remove the old one\n      const result = await deleteRuleGroup({\n        rulerConfig,\n        namespace: oldNamespace,\n        group: oldGroupName,\n        notificationOptions: { showSuccessAlert: false },\n      }).unwrap();\n\n      return result;\n    }\n  );\n}\n\n/**\n * Rename a rule group but keep it within the same namespace, throws if the action targets an existing rule group.\n * Optionally, update the rule group evaluation interval.\n */\nexport function useRenameRuleGroup() {\n  const [produceNewRuleGroup] = useProduceNewRuleGroup();\n  const [fetchRuleGroup] = alertRuleApi.endpoints.getRuleGroupForNamespace.useLazyQuery();\n  const [upsertRuleGroup] = alertRuleApi.endpoints.upsertRuleGroupForNamespace.useMutation();\n  const [deleteRuleGroup] = alertRuleApi.endpoints.deleteRuleGroupFromNamespace.useMutation();\n\n  return useAsync(async (ruleGroup: RuleGroupIdentifier, groupName: string, interval?: string) => {\n    const action = renameRuleGroupAction({ groupName, interval });\n    const { newRuleGroupDefinition, rulerConfig } = await produceNewRuleGroup(ruleGroup, action);\n\n    const oldGroupName = ruleGroup.groupName;\n    const newGroupName = action.payload.groupName;\n    const namespaceName = ruleGroup.namespaceName;\n\n    const successMessage = t('alerting.rule-groups.rename.success', 'Successfully renamed rule group');\n\n    // check if the target group exists\n    const targetGroup = await fetchRuleGroup({\n      rulerConfig,\n      namespace: namespaceName,\n      group: newGroupName,\n      // since this could throw 404\n      notificationOptions: { showErrorAlert: false },\n    })\n      .unwrap()\n      .catch(notFoundToNullOrThrow);\n\n    if (targetGroup?.rules?.length) {\n      throw new Error('Target group has existing rules, merging rule groups is currently not supported.');\n    }\n\n    // if the target group does not exist, create the new group\n    // ⚠️ it's important to do this before we remove the old group – better to have two groups than none if one of these requests fails\n    const result = await upsertRuleGroup({\n      rulerConfig,\n      namespace: namespaceName,\n      payload: newRuleGroupDefinition,\n      notificationOptions: { successMessage },\n    }).unwrap();\n\n    // now delete the group we renamed\n    await deleteRuleGroup({\n      rulerConfig,\n      namespace: namespaceName,\n      group: oldGroupName,\n      notificationOptions: { showSuccessAlert: false },\n    }).unwrap();\n\n    return result;\n  });\n}\n\n/**\n * Reorder rules within an existing rule group. Pass in an array of swap operations Array<[oldIndex, newIndex]>.\n * This prevents rules from accidentally being updated and only allows indices to be moved around.\n */\nexport function useReorderRuleForRuleGroup() {\n  const [produceNewRuleGroup] = useProduceNewRuleGroup();\n  const [upsertRuleGroup] = alertRuleApi.endpoints.upsertRuleGroupForNamespace.useMutation();\n\n  return useAsync(async (ruleGroup: RuleGroupIdentifier, swaps: Array<[number, number]>) => {\n    const { namespaceName } = ruleGroup;\n\n    const action = reorderRulesInRuleGroupAction({ swaps });\n    const { newRuleGroupDefinition, rulerConfig } = await produceNewRuleGroup(ruleGroup, action);\n\n    return upsertRuleGroup({\n      rulerConfig,\n      namespace: namespaceName,\n      payload: newRuleGroupDefinition,\n      notificationOptions: { successMessage: ruleUpdateSuccessMessage() },\n    }).unwrap();\n  });\n}\n","import { useMemo } from 'react';\n\nimport { getRulesAccess } from './access-control';\n\nexport function useRulesAccess() {\n  return useMemo(() => getRulesAccess(), []);\n}\n"],"names":["MAX_CONTACT_POINTS_RENDERED","sleep","ms","resolve","LOADING_SPINNER_DURATION","ContactPointSelector","selectProps","showRefreshButton","selectedContactPointName","selectedAlertmanager","contactPoints","isLoading","error","refetch","loaderSpinning","setLoaderSpinning","styles","getStyles","options","contactPoint","matchedContactPoint","option","onClickRefresh","rotation","theme","MIN_INTERVAl","QUICK_PICK_OPTIONS","minInterval","DEFAULT_INTERVAL_OPTIONS","minEvaluationIntervalMillis","head","millis","tail","index","lastInterval","multiplier","EvaluationGroupQuickPick","currentInterval","onSelect","interval","isActive","GrafanaAlertStatePicker","includeNoData","includeError","props","opts","opt","Select","getPendingPeriodQuickOptions","groupEvaluationInterval","groupEvaluationIntervalMillis","PendingPeriodQuickPick","selectedPendingPeriod","isQuickSelectionActive","duration","Stack","Button","MIN_TIME_RANGE_STEP_S","MAX_GROUP_RESULTS","useFetchGroupsForFolder","folderUid","alertRuleApi","namespaceToGroupOptions","rulerNamespace","enableProvisionedGroups","group","isProvisioned","isProvisionedGroup","sortByLabel","rule","b","forValidationOptions","evaluateEvery","value","millisFor","millisEvery","GrafanaEvaluationBehaviorStep","existing","showErrorHandling","setShowErrorHandling","watch","setValue","getValues","errors","control","type","isPaused","folder","isGrafanaAlertingRule","isGrafanaRecordingRule","loadingGroups","groupOptions","existingGroup","ruleGroup","isCreatingEvaluationGroup","setIsCreatingEvaluationGroup","handleEvalGroupCreation","groupName","evaluationInterval","defaultGroupValue","pauseContentText","onOpenEvaluationGroupCreationModal","step","label","RuleEditorSection","getDescription","Field","ref","field","fieldState","Provisioning","Box","Text","selectors","EvaluationGroupCreationModal","ForInput","Switch","Tooltip","Icon","CollapseToggle","collapsed","NeedHelpInfoForConfigureNoDataError","onChange","onClose","onCreate","groupfoldersForGrafana","evaluateEveryId","evaluationGroupNameId","folderName","formAPI","register","handleSubmit","formState","watchGroupFormValues","groupRules","g","onSubmit","onCancel","setEvaluationInterval","modalTitle","Modal","Label","Input","evaluateForId","currentPendingPeriod","setPendingPeriod","pendingPeriod","NeedHelpInfo","EvaluationIntervalLimitExceeded","Alert","useRuleGroupDefinition","ITEMS_PER_PAGE","ForBadge","message","Badge","isValidEvaluation","evaluation","RulesForGroupTable","rulesWithoutRecordingRules","unknownCurrentInterval","rows","alert1","alert2","columns","alertName","forDuration","numberEvaluations","DynamicTable","evaluateEveryValidationOptions","rules","rulePendingPeriods","largestPendingPeriod","period","EditRuleGroupModal","ruleGroupIdentifier","rulerConfig","intervalEditOnly","isGrafanaManagedGroup","loadingText","LoadingPlaceholder","EditRuleGroupModalForm","folderTitle","notifyApp","updateRuleGroup","updateRuleGroupState","useUpdateRuleGroup","renameRuleGroup","renameRuleGroupState","moveRuleGroup","moveRuleGroupState","loading","defaultValues","rulesSourceName","nameSpaceLabel","values","updatedNamespaceName","updatedGroupName","updatedInterval","shouldMove","shouldRename","isDirty","isValid","onInvalid","hasSomeNoRecordingRules","ruleUpdateSuccessMessage","useUpdateRuleGroupConfiguration","produceNewRuleGroup","upsertRuleGroup","namespaceName","action","newRuleGroupDefinition","useMoveRuleGroup","fetchRuleGroup","deleteRuleGroup","successMessage","oldNamespace","targetNamespace","oldGroupName","targetGroupName","useRenameRuleGroup","newGroupName","result","useReorderRuleForRuleGroup","swaps","useRulesAccess"],"sourceRoot":""}