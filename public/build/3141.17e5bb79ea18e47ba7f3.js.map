{"version":3,"file":"3141.17e5bb79ea18e47ba7f3.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/nodeGraph/EdgeArrowMarker.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/Edge.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/EdgeLabel.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/Legend.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/Marker.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/ViewControls.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/createLayoutWorker.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useNodeLimit.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/layout.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useContextMenu.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/useFocusPositionOnLayout.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useHighlight.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/usePanning.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/useZoom.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/NodeGraph.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/useCategorizeFrames.ts"],"sourcesContent":["import { defaultEdgeColor } from './Edge';\n\n/**\n * In SVG you need to supply this kind of marker that can be then referenced from a line segment as an ending of the\n * line turning in into arrow. Needs to be included in the svg element and then referenced as markerEnd=\"url(#triangle)\"\n */\nexport function EdgeArrowMarker({\n  id = 'triangle',\n  fill = defaultEdgeColor,\n  headHeight = 10,\n}: {\n  id?: string;\n  fill?: string;\n  headHeight?: number;\n}) {\n  return (\n    <defs>\n      <marker\n        id={id}\n        viewBox=\"0 0 10 10\"\n        refX=\"1\" // shift the arrow head slightly closer to the center of the line it will be attached to, to ensure no empty space is shown between the line and the arrow head\n        refY=\"5\"\n        markerUnits=\"userSpaceOnUse\"\n        markerWidth={headHeight} // equal to the height just for simplicily\n        markerHeight={headHeight}\n        orient=\"auto\"\n      >\n        <path d=\"M 0 0 L 10 5 L 0 10 z\" fill={fill} />\n      </marker>\n    </defs>\n  );\n}\n","import { MouseEvent, memo } from 'react';\n\nimport { EdgeArrowMarker } from './EdgeArrowMarker';\nimport { computeNodeCircumferenceStrokeWidth, nodeR } from './Node';\nimport { EdgeDatumLayout, NodeDatum } from './types';\nimport { shortenLine } from './utils';\n\nexport const defaultHighlightedEdgeColor = '#a00';\nexport const defaultEdgeColor = '#999';\n\ninterface Props {\n  edge: EdgeDatumLayout;\n  hovering: boolean;\n  svgIdNamespace: string;\n  onClick: (event: MouseEvent<SVGElement>, link: EdgeDatumLayout) => void;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n}\n\nexport const Edge = memo(function Edge(props: Props) {\n  const { edge, onClick, onMouseEnter, onMouseLeave, hovering, svgIdNamespace } = props;\n\n  // Not great typing but after we do layout these properties are full objects not just references\n  const { source, target, sourceNodeRadius, targetNodeRadius } = edge as {\n    source: NodeDatum;\n    target: NodeDatum;\n    sourceNodeRadius: number;\n    targetNodeRadius: number;\n  };\n  const arrowHeadHeight = 10 + edge.thickness * 2; // resized value, just to make the UI nicer\n\n  // As the nodes have some radius we want edges to end outside of the node circle.\n  const line = shortenLine(\n    {\n      x1: source.x!,\n      y1: source.y!,\n      x2: target.x!,\n      y2: target.y!,\n    },\n    sourceNodeRadius + computeNodeCircumferenceStrokeWidth(sourceNodeRadius) / 2 || nodeR,\n    targetNodeRadius + computeNodeCircumferenceStrokeWidth(targetNodeRadius) / 2 || nodeR,\n    arrowHeadHeight\n  );\n\n  const edgeColor = edge.color || defaultEdgeColor;\n\n  // @deprecated -- until 'highlighted' is removed we'll prioritize 'color'\n  // in case both are provided\n  const highlightedEdgeColor = edge.color || defaultHighlightedEdgeColor;\n\n  const markerId = `triangle-${svgIdNamespace}-${edge.id}`;\n  const coloredMarkerId = `triangle-colored-${svgIdNamespace}-${edge.id}`;\n\n  return (\n    <>\n      <EdgeArrowMarker id={markerId} fill={edgeColor} headHeight={arrowHeadHeight} />\n      <EdgeArrowMarker id={coloredMarkerId} fill={highlightedEdgeColor} headHeight={arrowHeadHeight} />\n      <g\n        onClick={(event) => onClick(event, edge)}\n        style={{ cursor: 'pointer' }}\n        aria-label={`Edge from: ${source.id} to: ${target.id}`}\n      >\n        <line\n          strokeWidth={(hovering ? 1 : 0) + (edge.highlighted ? 1 : 0) + edge.thickness}\n          stroke={edge.highlighted ? highlightedEdgeColor : edgeColor}\n          x1={line.x1}\n          y1={line.y1}\n          x2={line.x2}\n          y2={line.y2}\n          strokeDasharray={edge.strokeDasharray}\n          markerEnd={`url(#${edge.highlighted ? coloredMarkerId : markerId})`}\n        />\n        <line\n          stroke={'transparent'}\n          x1={line.x1}\n          y1={line.y1}\n          x2={line.x2}\n          y2={line.y2}\n          strokeWidth={20}\n          onMouseEnter={() => {\n            onMouseEnter(edge.id);\n          }}\n          onMouseLeave={() => {\n            onMouseLeave(edge.id);\n          }}\n        />\n      </g>\n    </>\n  );\n});\n","import { css } from '@emotion/css';\nimport { memo } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { useStyles2 } from '@grafana/ui';\n\nimport { nodeR } from './Node';\nimport { EdgeDatumLayout } from './types';\nimport { shortenLine } from './utils';\n\nconst getStyles = (theme: GrafanaTheme2) => {\n  return {\n    mainGroup: css({\n      pointerEvents: 'none',\n      fontSize: '8px',\n    }),\n\n    background: css({\n      fill: theme.components.tooltip.background,\n    }),\n\n    text: css({\n      fill: theme.components.tooltip.text,\n    }),\n  };\n};\n\ninterface Props {\n  edge: EdgeDatumLayout;\n}\nexport const EdgeLabel = memo(function EdgeLabel(props: Props) {\n  const { edge } = props;\n  // Not great typing, but after we do layout these properties are full objects not just references\n  const { source, target, sourceNodeRadius, targetNodeRadius } = edge;\n\n  // As the nodes have some radius we want edges to end outside the node circle.\n  const line = shortenLine(\n    {\n      x1: source.x!,\n      y1: source.y!,\n      x2: target.x!,\n      y2: target.y!,\n    },\n    sourceNodeRadius || nodeR,\n    targetNodeRadius || nodeR\n  );\n\n  const middle = {\n    x: line.x1 + (line.x2 - line.x1) / 2,\n    y: line.y1 + (line.y2 - line.y1) / 2,\n  };\n  const styles = useStyles2(getStyles);\n\n  const stats = [edge.mainStat, edge.secondaryStat].filter((x) => x);\n  const height = stats.length > 1 ? '30' : '15';\n  const middleOffset = stats.length > 1 ? 15 : 7.5;\n  let offset = stats.length > 1 ? -5 : 2.5;\n\n  const contents: JSX.Element[] = [];\n  stats.forEach((stat, index) => {\n    contents.push(\n      <text key={index} className={styles.text} x={middle.x} y={middle.y + offset} textAnchor={'middle'}>\n        {stat}\n      </text>\n    );\n    offset += 15;\n  });\n\n  return (\n    <g className={styles.mainGroup}>\n      <rect\n        className={styles.background}\n        x={middle.x - 40}\n        y={middle.y - middleOffset}\n        width=\"80\"\n        height={height}\n        rx=\"5\"\n      />\n      {contents}\n    </g>\n  );\n});\n","import { css } from '@emotion/css';\nimport { useCallback } from 'react';\n\nimport { Field, FieldColorModeId, GrafanaTheme2 } from '@grafana/data';\nimport { LegendDisplayMode } from '@grafana/schema';\nimport { Icon, useStyles2, useTheme2, VizLegend, VizLegendItem, VizLegendListItem } from '@grafana/ui';\n\nimport { Config } from './layout';\nimport { NodeDatum } from './types';\n\nfunction getStyles() {\n  return {\n    item: css({\n      label: 'LegendItem',\n      flexGrow: 0,\n    }),\n\n    legend: css({\n      label: 'Legend',\n      pointerEvents: 'all',\n    }),\n  };\n}\n\ninterface Props {\n  nodes: NodeDatum[];\n  onSort: (sort: Config['sort']) => void;\n  sort?: Config['sort'];\n  sortable: boolean;\n}\n\nexport const Legend = function Legend(props: Props) {\n  const { nodes, onSort, sort, sortable } = props;\n\n  const theme = useTheme2();\n  const styles = useStyles2(getStyles);\n  const colorItems = getColorLegendItems(nodes, theme);\n\n  const onClick = useCallback(\n    (item: VizLegendItem<ItemData>) => {\n      onSort({\n        field: item.data!.field,\n        ascending: item.data!.field === sort?.field ? !sort?.ascending : false,\n      });\n    },\n    [sort, onSort]\n  );\n\n  return (\n    <VizLegend<ItemData>\n      className={styles.legend}\n      displayMode={LegendDisplayMode.List}\n      placement={'bottom'}\n      items={colorItems}\n      itemRenderer={(item) => {\n        return (\n          <>\n            <VizLegendListItem item={item} className={styles.item} onLabelClick={sortable ? onClick : undefined} />\n            {sortable &&\n              (sort?.field === item.data!.field ? <Icon name={sort!.ascending ? 'arrow-up' : 'arrow-down'} /> : '')}\n          </>\n        );\n      }}\n    />\n  );\n};\n\ninterface ItemData {\n  field: Field;\n}\n\nfunction getColorLegendItems(nodes: NodeDatum[], theme: GrafanaTheme2): Array<VizLegendItem<ItemData>> {\n  if (!nodes.length) {\n    return [];\n  }\n  const fields = [nodes[0].mainStat, nodes[0].secondaryStat].filter((item): item is NonNullable<typeof item> =>\n    Boolean(item)\n  );\n\n  const node = nodes.find((n) => n.arcSections.length > 0);\n  if (node) {\n    if (node.arcSections[0]!.config?.color?.mode === FieldColorModeId.Fixed) {\n      // We assume in this case we have a set of fixed colors which map neatly into a basic legend.\n\n      // Lets collect and deduplicate as there isn't a requirement for 0 size arc section to be defined\n      fields.push(...new Set(nodes.map((n) => n.arcSections).flat()));\n    }\n  }\n\n  if (nodes[0].color) {\n    fields.push(nodes[0].color);\n  }\n\n  return fields.map((f) => {\n    const item: VizLegendItem = {\n      label: f.config.displayName || f.name,\n      yAxis: 0,\n      data: { field: f },\n    };\n    if (f.config.color?.mode === FieldColorModeId.Fixed && f.config.color?.fixedColor) {\n      item.color = theme.visualization.getColorByName(f.config.color?.fixedColor || '');\n    } else if (f.config.color?.mode) {\n      item.gradient = f.config.color?.mode;\n    }\n\n    if (!(item.color || item.gradient)) {\n      // Defaults to gray color\n      item.color = theme.visualization.getColorByName('');\n    }\n\n    return item;\n  });\n}\n","import { css } from '@emotion/css';\nimport { MouseEvent, memo } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { useStyles2 } from '@grafana/ui';\n\nimport { NodesMarker } from './types';\n\nconst nodeR = 40;\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  mainGroup: css({\n    cursor: 'pointer',\n    fontSize: '10px',\n  }),\n\n  mainCircle: css({\n    fill: theme.components.panel.background,\n    stroke: theme.colors.border.strong,\n  }),\n  text: css({\n    width: '50px',\n    height: '50px',\n    textAlign: 'center',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n  }),\n});\n\nexport const Marker = memo(function Marker(props: {\n  marker: NodesMarker;\n  onClick?: (event: MouseEvent<SVGElement>, marker: NodesMarker) => void;\n}) {\n  const { marker, onClick } = props;\n  const { node } = marker;\n  const styles = useStyles2(getStyles);\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return (\n    <g\n      data-node-id={node.id}\n      className={styles.mainGroup}\n      onClick={(event) => {\n        onClick?.(event, marker);\n      }}\n      aria-label={`Hidden nodes marker: ${node.id}`}\n    >\n      <circle className={styles.mainCircle} r={nodeR} cx={node.x} cy={node.y} />\n      <g>\n        <foreignObject x={node.x - 25} y={node.y - 25} width=\"50\" height=\"50\">\n          <div className={styles.text}>\n            {/* we limit the count to 101 so if we have more than 100 nodes we don't have exact count */}\n            <span>{marker.count > 100 ? '>100' : marker.count} nodes</span>\n          </div>\n        </foreignObject>\n      </g>\n    </g>\n  );\n});\n","import { css } from '@emotion/css';\nimport { useState } from 'react';\n\nimport { Button, HorizontalGroup, useStyles2, VerticalGroup } from '@grafana/ui';\n\nfunction getStyles() {\n  return {\n    wrapper: css({\n      label: 'wrapper',\n      pointerEvents: 'all',\n    }),\n  };\n}\n\ninterface Props<Config> {\n  config: Config;\n  onConfigChange: (config: Config) => void;\n  onPlus: () => void;\n  onMinus: () => void;\n  scale: number;\n  disableZoomOut?: boolean;\n  disableZoomIn?: boolean;\n}\n\n/**\n * Control buttons for zoom but also some layout config inputs mainly for debugging.\n */\nexport function ViewControls<Config extends Record<string, any>>(props: Props<Config>) {\n  const { config, onConfigChange, onPlus, onMinus, disableZoomOut, disableZoomIn } = props;\n  const [showConfig, setShowConfig] = useState(false);\n\n  // For debugging the layout, should be removed here and maybe moved to panel config later on\n  const allowConfiguration = false;\n  const styles = useStyles2(getStyles);\n\n  return (\n    <div className={styles.wrapper}>\n      <VerticalGroup spacing=\"sm\">\n        <HorizontalGroup spacing=\"xs\">\n          <Button\n            icon={'plus-circle'}\n            onClick={onPlus}\n            size={'md'}\n            title={'Zoom in'}\n            variant=\"secondary\"\n            disabled={disableZoomIn}\n          />\n          <Button\n            icon={'minus-circle'}\n            onClick={onMinus}\n            size={'md'}\n            title={'Zoom out'}\n            variant=\"secondary\"\n            disabled={disableZoomOut}\n          />\n        </HorizontalGroup>\n        <HorizontalGroup spacing=\"xs\">\n          <Button\n            icon={'code-branch'}\n            onClick={() => onConfigChange({ ...config, gridLayout: false })}\n            size={'md'}\n            title={'Default layout'}\n            variant=\"secondary\"\n            disabled={!config.gridLayout}\n          />\n          <Button\n            icon={'apps'}\n            onClick={() => onConfigChange({ ...config, gridLayout: true })}\n            size={'md'}\n            title={'Grid layout'}\n            variant=\"secondary\"\n            disabled={config.gridLayout}\n          />\n        </HorizontalGroup>\n      </VerticalGroup>\n\n      {allowConfiguration && (\n        <Button size={'xs'} fill=\"text\" onClick={() => setShowConfig((showConfig) => !showConfig)}>\n          {showConfig ? 'Hide config' : 'Show config'}\n        </Button>\n      )}\n\n      {allowConfiguration &&\n        showConfig &&\n        Object.keys(config)\n          .filter((k) => k !== 'show')\n          .map((k) => (\n            <div key={k}>\n              {k}\n              <input\n                style={{ width: 50 }}\n                type={'number'}\n                value={config[k]}\n                onChange={(e) => {\n                  onConfigChange({ ...config, [k]: parseFloat(e.target.value) });\n                }}\n              />\n            </div>\n          ))}\n    </div>\n  );\n}\n","import { CorsWorker as Worker } from 'app/core/utils/CorsWorker';\n\nexport const createWorker = () => new Worker(new URL('./layout.worker.js', import.meta.url));\nexport const createMsaglWorker = () => new Worker(new URL('./layeredLayout.worker.js', import.meta.url));\n","import { fromPairs, uniq } from 'lodash';\nimport { useMemo } from 'react';\n\nimport { Config } from './layout';\nimport { EdgeDatumLayout, NodeDatum, NodesMarker } from './types';\n\ntype NodesMap = Record<string, NodeDatum>;\ntype EdgesMap = Record<string, EdgeDatumLayout[]>;\n\n/**\n * Limits the number of nodes by going from the roots breadth first until we have desired number of nodes.\n */\nexport function useNodeLimit(\n  nodes: NodeDatum[],\n  edges: EdgeDatumLayout[],\n  limit: number,\n  config: Config,\n  rootId?: string\n): { nodes: NodeDatum[]; edges: EdgeDatumLayout[]; markers?: NodesMarker[] } {\n  // This is pretty expensive also this happens once in the layout code when initializing position but it's a bit\n  // tricky to do it only once and reuse the results because layout directly modifies the nodes.\n  const [edgesMap, nodesMap] = useMemo(() => {\n    // Make sure we don't compute this until we have all the data.\n    if (!(nodes.length && edges.length)) {\n      return [{}, {}];\n    }\n\n    const edgesMap = edges.reduce<EdgesMap>((acc, e) => {\n      acc[e.source.id] = [...(acc[e.source.id] ?? []), e];\n      acc[e.target.id] = [...(acc[e.target.id] ?? []), e];\n      return acc;\n    }, {});\n\n    const nodesMap = nodes.reduce<NodesMap>((acc, node) => {\n      acc[node.id] = node;\n      return acc;\n    }, {});\n    return [edgesMap, nodesMap];\n  }, [edges, nodes]);\n\n  return useMemo(() => {\n    if (nodes.length <= limit) {\n      return { nodes, edges };\n    }\n\n    if (config.gridLayout) {\n      return limitGridLayout(nodes, limit, rootId);\n    }\n\n    return limitGraphLayout(nodes, edges, nodesMap, edgesMap, limit, rootId);\n  }, [edges, edgesMap, limit, nodes, nodesMap, rootId, config.gridLayout]);\n}\n\nexport function limitGraphLayout(\n  nodes: NodeDatum[],\n  edges: EdgeDatumLayout[],\n  nodesMap: NodesMap,\n  edgesMap: EdgesMap,\n  limit: number,\n  rootId?: string\n) {\n  let roots;\n  if (rootId) {\n    roots = [nodesMap[rootId]];\n  } else {\n    roots = nodes.filter((n) => n.incoming === 0);\n    // TODO: same code as layout\n    if (!roots.length) {\n      roots = [nodes[0]];\n    }\n  }\n\n  const { visibleNodes, markers } = collectVisibleNodes(limit, roots, nodesMap, edgesMap);\n\n  const markersWithStats = collectMarkerStats(markers, visibleNodes, nodesMap, edgesMap);\n  const markersMap = fromPairs(markersWithStats.map((m) => [m.node.id, m]));\n\n  for (const marker of markersWithStats) {\n    if (marker.count === 1) {\n      delete markersMap[marker.node.id];\n      visibleNodes[marker.node.id] = marker.node;\n    }\n  }\n\n  // Show all edges between visible nodes or placeholder markers\n  const visibleEdges = edges.filter(\n    (e) =>\n      (visibleNodes[e.source.id] || markersMap[e.source.id]) && (visibleNodes[e.target.id] || markersMap[e.target.id])\n  );\n\n  return {\n    nodes: Object.values(visibleNodes),\n    edges: visibleEdges,\n    markers: Object.values(markersMap),\n  };\n}\n\nexport function limitGridLayout(nodes: NodeDatum[], limit: number, rootId?: string) {\n  let start = 0;\n  let stop = limit;\n  let markers: NodesMarker[] = [];\n\n  if (rootId) {\n    const index = nodes.findIndex((node) => node.id === rootId);\n    const prevLimit = Math.floor(limit / 2);\n    let afterLimit = prevLimit;\n    start = index - prevLimit;\n    if (start < 0) {\n      afterLimit += Math.abs(start);\n      start = 0;\n    }\n    stop = index + afterLimit + 1;\n\n    if (stop > nodes.length) {\n      if (start > 0) {\n        start = Math.max(0, start - (stop - nodes.length));\n      }\n      stop = nodes.length;\n    }\n\n    if (start > 1) {\n      markers.push({ node: nodes[start - 1], count: start });\n    }\n\n    if (nodes.length - stop > 1) {\n      markers.push({ node: nodes[stop], count: nodes.length - stop });\n    }\n  } else {\n    if (nodes.length - limit > 1) {\n      markers = [{ node: nodes[limit], count: nodes.length - limit }];\n    }\n  }\n\n  return {\n    nodes: nodes.slice(start, stop),\n    edges: [],\n    markers,\n  };\n}\n\n/**\n * Breath first traverse of the graph collecting all the nodes until we reach the limit. It also returns markers which\n * are nodes on the edges which did not make it into the limit but can be used as clickable markers for manually\n * expanding the graph.\n * @param limit\n * @param roots - Nodes where to start the traversal. In case of exploration this can be any node that user clicked on.\n * @param nodesMap - Node id to node\n * @param edgesMap - This is a map of node id to a list of edges (both ingoing and outgoing)\n */\nfunction collectVisibleNodes(\n  limit: number,\n  roots: NodeDatum[],\n  nodesMap: Record<string, NodeDatum>,\n  edgesMap: Record<string, EdgeDatumLayout[]>\n): { visibleNodes: Record<string, NodeDatum>; markers: NodeDatum[] } {\n  const visibleNodes: Record<string, NodeDatum> = {};\n  let stack = [...roots];\n\n  while (Object.keys(visibleNodes).length < limit && stack.length > 0) {\n    let current = stack.shift()!;\n\n    // We are already showing this node. This can happen because graphs can be cyclic\n    if (visibleNodes[current!.id]) {\n      continue;\n    }\n\n    // Show this node\n    visibleNodes[current.id] = current;\n    const edges = edgesMap[current.id] || [];\n\n    // Add any nodes that are connected to it on top of the stack to be considered in the next pass\n    const connectedNodes = edges.map((e) => {\n      // We don't care about direction here. Should not make much difference but argument could be made that with\n      // directed graphs it should walk the graph directionally. Problem is when we focus on a node in the middle of\n      // graph (not going from the \"natural\" root) we also want to show what was \"before\".\n      const id = e.source.id === current.id ? e.target.id : e.source.id;\n      return nodesMap[id];\n    });\n    stack = stack.concat(connectedNodes);\n  }\n\n  // Right now our stack contains all the nodes which are directly connected to the graph but did not make the cut.\n  // Some of them though can be nodes we already are showing so we have to filter them and then use them as markers.\n  const markers = uniq(stack.filter((n) => !visibleNodes[n.id]));\n\n  return { visibleNodes, markers };\n}\n\nfunction collectMarkerStats(\n  markers: NodeDatum[],\n  visibleNodes: Record<string, NodeDatum>,\n  nodesMap: Record<string, NodeDatum>,\n  edgesMap: Record<string, EdgeDatumLayout[]>\n): NodesMarker[] {\n  return markers.map((marker) => {\n    const nodesToCount: Record<string, NodeDatum> = {};\n    let count = 0;\n    let stack = [marker];\n    while (stack.length > 0 && count <= 101) {\n      let current = stack.shift()!;\n\n      // We are showing this node so not going to count it as hidden.\n      if (visibleNodes[current.id] || nodesToCount[current.id]) {\n        continue;\n      }\n\n      if (!nodesToCount[current.id]) {\n        count++;\n      }\n      nodesToCount[current.id] = current;\n\n      const edges = edgesMap[current.id] || [];\n\n      const connectedNodes = edges.map((e) => {\n        const id = e.source.id === current.id ? e.target.id : e.source.id;\n        return nodesMap[id];\n      });\n      stack = stack.concat(connectedNodes);\n    }\n\n    return {\n      node: marker,\n      count: count,\n    };\n  });\n}\n","import { fromPairs } from 'lodash';\nimport { useEffect, useMemo, useRef, useState } from 'react';\nimport { useUnmount } from 'react-use';\nimport useMountedState from 'react-use/lib/useMountedState';\n\nimport { Field } from '@grafana/data';\nimport { config as grafanaConfig } from '@grafana/runtime';\n\nimport { createWorker, createMsaglWorker } from './createLayoutWorker';\nimport { EdgeDatum, EdgeDatumLayout, NodeDatum } from './types';\nimport { useNodeLimit } from './useNodeLimit';\nimport { graphBounds } from './utils';\n\nexport interface Config {\n  linkDistance: number;\n  linkStrength: number;\n  forceX: number;\n  forceXStrength: number;\n  forceCollide: number;\n  tick: number;\n  gridLayout: boolean;\n  sort?: {\n    // Either a arc field or stats field\n    field: Field;\n    ascending: boolean;\n  };\n}\n\n// Config mainly for the layout but also some other parts like current layout. The layout variables can be changed only\n// if you programmatically enable the config editor (for development only) see ViewControls. These could be moved to\n// panel configuration at some point (apart from gridLayout as that can be switched be user right now.).\nexport const defaultConfig: Config = {\n  linkDistance: 150,\n  linkStrength: 0.5,\n  forceX: 2000,\n  forceXStrength: 0.02,\n  forceCollide: 100,\n  tick: 300,\n  gridLayout: false,\n};\n\n/**\n * This will return copy of the nods and edges with x,y positions filled in. Also the layout changes source/target props\n * in edges from string ids to actual nodes.\n */\nexport function useLayout(\n  rawNodes: NodeDatum[],\n  rawEdges: EdgeDatum[],\n  config: Config = defaultConfig,\n  nodeCountLimit: number,\n  width: number,\n  rootNodeId?: string,\n  hasFixedPositions?: boolean\n) {\n  const [nodesGraph, setNodesGraph] = useState<NodeDatum[]>([]);\n  const [edgesGraph, setEdgesGraph] = useState<EdgeDatumLayout[]>([]);\n\n  const [loading, setLoading] = useState(false);\n\n  const isMounted = useMountedState();\n  const layoutWorkerCancelRef = useRef<(() => void) | undefined>();\n\n  useUnmount(() => {\n    if (layoutWorkerCancelRef.current) {\n      layoutWorkerCancelRef.current();\n    }\n  });\n\n  // Also we compute both layouts here. Grid layout should not add much time and we can more easily just cache both\n  // so this should happen only once for a given response data.\n  //\n  // Also important note is that right now this works on all the nodes even if they are not visible. This means that\n  // the node position is stable even when expanding different parts of graph. It seems like a reasonable thing but\n  // implications are that:\n  // - limiting visible nodes count does not have a positive perf effect\n  // - graphs with high node count can seem weird (very sparse or spread out) when we show only some nodes but layout\n  //   is done for thousands of nodes but we also do this only once in the graph lifecycle.\n  // We could re-layout this on visible nodes change but this may need smaller visible node limit to keep the perf\n  // (as we would run layout on every click) and also would be very weird without any animation to understand what is\n  // happening as already visible nodes would change positions.\n  useEffect(() => {\n    if (rawNodes.length === 0) {\n      setNodesGraph([]);\n      setEdgesGraph([]);\n      setLoading(false);\n      return;\n    }\n\n    if (hasFixedPositions) {\n      setNodesGraph(rawNodes);\n      // The layout function turns source and target fields from string to NodeDatum, so we do that here as well.\n      const nodesMap = fromPairs(rawNodes.map((node) => [node.id, node]));\n      setEdgesGraph(\n        rawEdges.map(\n          (e): EdgeDatumLayout => ({\n            ...e,\n            source: nodesMap[e.source],\n            target: nodesMap[e.target],\n          })\n        )\n      );\n      setLoading(false);\n      return;\n    }\n\n    // Layered layout is better but also more expensive, so we switch to default force based layout for bigger graphs.\n    const layoutType =\n      grafanaConfig.featureToggles.nodeGraphDotLayout && rawNodes.length <= 500 ? 'layered' : 'default';\n\n    setLoading(true);\n    // This is async but as I wanted to still run the sync grid layout, and you cannot return promise from effect so\n    // having callback seems ok here.\n    const cancel = layout(rawNodes, rawEdges, layoutType, ({ nodes, edges }) => {\n      if (isMounted()) {\n        setNodesGraph(nodes);\n        setEdgesGraph(edges);\n        setLoading(false);\n      }\n    });\n    layoutWorkerCancelRef.current = cancel;\n    return cancel;\n  }, [hasFixedPositions, rawNodes, rawEdges, isMounted]);\n\n  // Compute grid separately as it is sync and do not need to be inside effect. Also it is dependant on width while\n  // default layout does not care and we don't want to recalculate that on panel resize.\n  const [nodesGrid, edgesGrid] = useMemo(() => {\n    if (rawNodes.length === 0) {\n      return [[], []];\n    }\n\n    const rawNodesCopy = rawNodes.map((n) => ({ ...n }));\n    const rawEdgesCopy = rawEdges.map((e) => ({ ...e }));\n    gridLayout(rawNodesCopy, width, config.sort);\n\n    return [rawNodesCopy, rawEdgesCopy as EdgeDatumLayout[]];\n  }, [config.sort, rawNodes, rawEdges, width]);\n\n  // Limit the nodes so we don't show all for performance reasons. Here we don't compute both at the same time so\n  // changing the layout can trash internal memoization at the moment.\n  const {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers,\n  } = useNodeLimit(\n    config.gridLayout ? nodesGrid : nodesGraph,\n    config.gridLayout ? edgesGrid : edgesGraph,\n    nodeCountLimit,\n    config,\n    rootNodeId\n  );\n\n  // Get bounds based on current limited number of nodes.\n  const bounds = useMemo(\n    () => graphBounds([...nodesWithLimit, ...(markers || []).map((m) => m.node)]),\n    [nodesWithLimit, markers]\n  );\n\n  return {\n    nodes: nodesWithLimit,\n    edges: edgesWithLimit,\n    markers,\n    bounds,\n    hiddenNodesCount: rawNodes.length - nodesWithLimit.length,\n    loading,\n  };\n}\n\n/**\n * Wraps the layout code in a worker as it can take long and we don't want to block the main thread.\n * Returns a cancel function to terminate the worker.\n */\nfunction layout(\n  nodes: NodeDatum[],\n  edges: EdgeDatum[],\n  engine: 'default' | 'layered',\n  done: (data: { nodes: NodeDatum[]; edges: EdgeDatumLayout[] }) => void\n) {\n  const worker = engine === 'default' ? createWorker() : createMsaglWorker();\n\n  worker.onmessage = (event: MessageEvent<{ nodes: NodeDatum[]; edges: EdgeDatumLayout[] }>) => {\n    const nodesMap = fromPairs(nodes.map((node) => [node.id, node]));\n\n    // Add the x,y coordinates from the layout algorithm to the original nodes.\n    event.data.nodes = event.data.nodes.map((node) => {\n      return {\n        ...nodesMap[node.id],\n        ...node,\n      };\n    });\n\n    done(event.data);\n  };\n\n  worker.postMessage({\n    nodes: nodes.map((n) => ({\n      id: n.id,\n      incoming: n.incoming,\n    })),\n    edges,\n    config: defaultConfig,\n  });\n\n  return () => {\n    worker.terminate();\n  };\n}\n\n/**\n * Set the nodes in simple grid layout sorted by some stat.\n */\nfunction gridLayout(\n  nodes: NodeDatum[],\n  width: number,\n  sort?: {\n    field: Field;\n    ascending: boolean;\n  }\n) {\n  const spacingVertical = 140;\n  const spacingHorizontal = 120;\n  const padding = spacingHorizontal / 2;\n  const perRow = Math.min(Math.floor((width - padding * 2) / spacingVertical), nodes.length);\n  const midPoint = Math.floor(((perRow - 1) * spacingHorizontal) / 2);\n\n  if (sort) {\n    nodes.sort((node1, node2) => {\n      const val1 = sort!.field.values[node1.dataFrameRowIndex];\n      const val2 = sort!.field.values[node2.dataFrameRowIndex];\n\n      // Let's pretend we don't care about type of the stats for a while (they can be strings)\n      return sort!.ascending ? val1 - val2 : val2 - val1;\n    });\n  }\n\n  for (const [index, node] of nodes.entries()) {\n    const row = Math.floor(index / perRow);\n    const column = index % perRow;\n    node.x = column * spacingHorizontal - midPoint;\n    node.y = -60 + row * spacingVertical;\n  }\n}\n","import { css } from '@emotion/css';\nimport { MouseEvent, useCallback, useState } from 'react';\nimport * as React from 'react';\n\nimport { DataFrame, Field, GrafanaTheme2, LinkModel, LinkTarget } from '@grafana/data';\nimport { ContextMenu, MenuGroup, MenuItem, useStyles2 } from '@grafana/ui';\n\nimport { Config } from './layout';\nimport { EdgeDatumLayout, NodeDatum } from './types';\nimport { getEdgeFields, getNodeFields, statToString } from './utils';\n\n/**\n * Hook that contains state of the context menu, both for edges and nodes and provides appropriate component when\n * opened context menu should be opened.\n */\nexport function useContextMenu(\n  getLinks: (dataFrame: DataFrame, rowIndex: number) => LinkModel[],\n  // This can be undefined if we only use edge dataframe\n  nodes: DataFrame | undefined,\n  // This can be undefined if we have only single node\n  edges: DataFrame | undefined,\n  config: Config,\n  setConfig: (config: Config) => void,\n  setFocusedNodeId: (id: string) => void\n): {\n  onEdgeOpen: (event: MouseEvent<SVGElement>, edge: EdgeDatumLayout) => void;\n  onNodeOpen: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n  MenuComponent: React.ReactNode;\n} {\n  const [menu, setMenu] = useState<JSX.Element | undefined>(undefined);\n\n  const onNodeOpen = useCallback(\n    (event: MouseEvent<SVGElement>, node: NodeDatum) => {\n      const [label, showGridLayout] = config.gridLayout\n        ? ['Show in Graph layout', false]\n        : ['Show in Grid layout', true];\n\n      const extraNodeItem = [\n        {\n          label: label,\n          onClick: (node: NodeDatum) => {\n            setFocusedNodeId(node.id);\n            setConfig({ ...config, gridLayout: showGridLayout });\n            setMenu(undefined);\n          },\n        },\n      ];\n\n      const links = nodes ? getLinks(nodes, node.dataFrameRowIndex) : [];\n      const renderer = getItemsRenderer(links, node, extraNodeItem);\n      setMenu(makeContextMenu(<NodeHeader node={node} nodes={nodes} />, event, setMenu, renderer));\n    },\n    [config, nodes, getLinks, setMenu, setConfig, setFocusedNodeId]\n  );\n\n  const onEdgeOpen = useCallback(\n    (event: MouseEvent<SVGElement>, edge: EdgeDatumLayout) => {\n      if (!edges) {\n        // This could happen if we have only one node and no edges, in which case this is not needed as there is no edge\n        // to click on.\n        return;\n      }\n      const links = getLinks(edges, edge.dataFrameRowIndex);\n      const renderer = getItemsRenderer(links, edge);\n      setMenu(makeContextMenu(<EdgeHeader edge={edge} edges={edges} />, event, setMenu, renderer));\n    },\n    [edges, getLinks, setMenu]\n  );\n\n  return { onEdgeOpen, onNodeOpen, MenuComponent: menu };\n}\n\nfunction makeContextMenu(\n  header: JSX.Element,\n  event: MouseEvent<SVGElement>,\n  setMenu: (el: JSX.Element | undefined) => void,\n  renderer?: () => React.ReactNode\n) {\n  return (\n    <ContextMenu\n      renderHeader={() => header}\n      renderMenuItems={renderer}\n      onClose={() => setMenu(undefined)}\n      x={event.pageX}\n      y={event.pageY}\n    />\n  );\n}\n\nfunction getItemsRenderer<T extends NodeDatum | EdgeDatumLayout>(\n  links: LinkModel[],\n  item: T,\n  extraItems?: Array<LinkData<T>> | undefined\n) {\n  if (!(links.length || extraItems?.length)) {\n    return undefined;\n  }\n  const items = getItems(links);\n  return () => {\n    let groups = items?.map((group, index) => (\n      <MenuGroup key={`${group.label}${index}`} label={group.label}>\n        {(group.items || []).map(mapMenuItem(item))}\n      </MenuGroup>\n    ));\n\n    if (extraItems) {\n      groups = [...extraItems.map(mapMenuItem(item)), ...groups];\n    }\n    return groups;\n  };\n}\n\nfunction mapMenuItem<T extends NodeDatum | EdgeDatumLayout>(item: T) {\n  return function NodeGraphMenuItem(link: LinkData<T>) {\n    return (\n      <MenuItem\n        key={link.label}\n        url={link.url}\n        label={link.label}\n        ariaLabel={link.ariaLabel}\n        onClick={\n          link.onClick\n            ? (event) => {\n                if (!(event?.ctrlKey || event?.metaKey || event?.shiftKey)) {\n                  event?.preventDefault();\n                  event?.stopPropagation();\n                  link.onClick?.(item);\n                }\n              }\n            : undefined\n        }\n        target={link.target || '_self'}\n      />\n    );\n  };\n}\n\ntype LinkData<T extends NodeDatum | EdgeDatumLayout> = {\n  label: string;\n  ariaLabel?: string;\n  url?: string;\n  onClick?: (item: T) => void;\n  target?: LinkTarget;\n};\n\nfunction getItems(links: LinkModel[]) {\n  const defaultGroup = 'Open in Explore';\n  const groups = links.reduce<{ [group: string]: Array<{ l: LinkModel; newTitle?: string }> }>((acc, l) => {\n    let group;\n    let title;\n    if (l.title.indexOf('/') !== -1) {\n      group = l.title.split('/')[0];\n      title = l.title.split('/')[1];\n      acc[group] = acc[group] || [];\n      acc[group].push({ l, newTitle: title });\n    } else {\n      acc[defaultGroup] = acc[defaultGroup] || [];\n      acc[defaultGroup].push({ l });\n    }\n\n    return acc;\n  }, {});\n\n  return Object.keys(groups).map((key) => {\n    return {\n      label: key,\n      ariaLabel: key,\n      items: groups[key].map((link) => ({\n        label: link.newTitle || link.l.title,\n        ariaLabel: link.newTitle || link.l.title,\n        url: link.l.href,\n        onClick: link.l.onClick,\n        target: link.l.target,\n      })),\n    };\n  });\n}\n\nfunction FieldRow({ field, index }: { field: Field; index: number }) {\n  return (\n    <HeaderRow\n      label={field.config?.displayName || field.name}\n      value={statToString(field.config, field.values[index] || '')}\n    />\n  );\n}\n\nfunction HeaderRow({ label, value }: { label: string; value: string }) {\n  const styles = useStyles2(getLabelStyles);\n  return (\n    <tr>\n      <td className={styles.label}>{label}: </td>\n      <td className={styles.value}>{value}</td>\n    </tr>\n  );\n}\n\n/**\n * Shows some field values in a table on top of the context menu.\n */\nfunction NodeHeader({ node, nodes }: { node: NodeDatum; nodes?: DataFrame }) {\n  const rows = [];\n  if (nodes) {\n    const fields = getNodeFields(nodes);\n    for (const f of [fields.title, fields.subTitle, fields.mainStat, fields.secondaryStat, ...fields.details]) {\n      if (f && f.values[node.dataFrameRowIndex]) {\n        rows.push(<FieldRow key={f.name} field={f} index={node.dataFrameRowIndex} />);\n      }\n    }\n  } else {\n    // Fallback if we don't have nodes dataFrame. Can happen if we use just the edges frame to construct this.\n    if (node.title) {\n      rows.push(<HeaderRow key=\"title\" label={'Title'} value={node.title} />);\n    }\n    if (node.subTitle) {\n      rows.push(<HeaderRow key=\"subtitle\" label={'Subtitle'} value={node.subTitle} />);\n    }\n  }\n\n  return (\n    <table style={{ width: '100%' }}>\n      <tbody>{rows}</tbody>\n    </table>\n  );\n}\n\n/**\n * Shows some of the field values in a table on top of the context menu.\n */\nfunction EdgeHeader(props: { edge: EdgeDatumLayout; edges: DataFrame }) {\n  const index = props.edge.dataFrameRowIndex;\n  const fields = getEdgeFields(props.edges);\n  const valueSource = fields.source?.values[index] || '';\n  const valueTarget = fields.target?.values[index] || '';\n\n  const rows = [];\n  if (valueSource && valueTarget) {\n    rows.push(<HeaderRow key={'header-row'} label={'Source → Target'} value={`${valueSource} → ${valueTarget}`} />);\n  }\n\n  for (const f of [fields.mainStat, fields.secondaryStat, ...fields.details]) {\n    if (f && f.values[index]) {\n      rows.push(<FieldRow key={`field-row-${index}`} field={f} index={index} />);\n    }\n  }\n\n  return (\n    <table style={{ width: '100%' }}>\n      <tbody>{rows}</tbody>\n    </table>\n  );\n}\n\nexport const getLabelStyles = (theme: GrafanaTheme2) => {\n  return {\n    label: css({\n      label: 'Label',\n      lineHeight: 1.25,\n      color: theme.colors.text.disabled,\n      fontSize: theme.typography.size.sm,\n      fontWeight: theme.typography.fontWeightMedium,\n      paddingRight: theme.spacing(1),\n    }),\n    value: css({\n      label: 'Value',\n      fontSize: theme.typography.size.sm,\n      fontWeight: theme.typography.fontWeightMedium,\n      color: theme.colors.text.primary,\n    }),\n  };\n};\n","import usePrevious from 'react-use/lib/usePrevious';\n\nimport { Config } from './layout';\nimport { NodeDatum } from './types';\n\nexport function useFocusPositionOnLayout(config: Config, nodes: NodeDatum[], focusedNodeId: string | undefined) {\n  const prevLayoutGrid = usePrevious(config.gridLayout);\n  let focusPosition;\n  if (prevLayoutGrid === true && !config.gridLayout && focusedNodeId) {\n    const node = nodes.find((n) => n.id === focusedNodeId);\n    if (node) {\n      focusPosition = {\n        x: -node.x!,\n        y: -node.y!,\n      };\n    }\n  }\n\n  return focusPosition;\n}\n","import { useEffect, useState } from 'react';\nimport useMountedState from 'react-use/lib/useMountedState';\n\nexport function useHighlight(focusedNodeId?: string) {\n  const [highlightId, setHighlightId] = useState<string>();\n  const mounted = useMountedState();\n  useEffect(() => {\n    if (focusedNodeId) {\n      setHighlightId(focusedNodeId);\n      setTimeout(() => {\n        if (mounted()) {\n          setHighlightId(undefined);\n        }\n      }, 500);\n    }\n  }, [focusedNodeId, mounted]);\n\n  return highlightId;\n}\n","import { useEffect, useRef, RefObject, useState, useMemo } from 'react';\nimport useMountedState from 'react-use/lib/useMountedState';\nimport usePrevious from 'react-use/lib/usePrevious';\n\nimport { Bounds } from './utils';\n\nexport interface State {\n  isPanning: boolean;\n  position: {\n    x: number;\n    y: number;\n  };\n}\n\ninterface Options {\n  scale?: number;\n  bounds?: Bounds;\n  focus?: {\n    x: number;\n    y: number;\n  };\n}\n\n/**\n * Based on https://github.com/streamich/react-use/blob/master/src/useSlider.ts\n * Returns position x/y coordinates which can be directly used in transform: translate().\n * @param scale - Can be used when we want to scale the movement if we are moving a scaled element. We need to do it\n *   here because we don't want to change the pos when scale changes.\n * @param bounds - If set the panning cannot go outside of those bounds.\n * @param focus - Position to focus on.\n */\nexport function usePanning<T extends Element>({ scale = 1, bounds, focus }: Options = {}): {\n  state: State;\n  ref: RefObject<T>;\n} {\n  const isMounted = useMountedState();\n  const isPanning = useRef(false);\n  const frame = useRef(0);\n  const panRef = useRef<T>(null);\n\n  const initial = { x: 0, y: 0 };\n  // As we return a diff of the view port to be applied we need as translate coordinates we have to invert the\n  // bounds of the content to get the bounds of the view port diff.\n  const viewBounds = useMemo(\n    () => ({\n      right: bounds ? -bounds.left : Infinity,\n      left: bounds ? -bounds.right : -Infinity,\n      bottom: bounds ? -bounds.top : -Infinity,\n      top: bounds ? -bounds.bottom : Infinity,\n    }),\n    [bounds]\n  );\n\n  // We need to keep some state so we can compute the position diff and add that to the previous position.\n  const startMousePosition = useRef(initial);\n  const prevPosition = useRef(initial);\n  // We cannot use the state as that would rerun the effect on each state change which we don't want so we have to keep\n  // separate variable for the state that won't cause useEffect eval\n  const currentPosition = useRef(initial);\n\n  const [state, setState] = useState<State>({\n    isPanning: false,\n    position: initial,\n  });\n\n  useEffect(() => {\n    const startPanning = (event: Event) => {\n      if (!isPanning.current && isMounted()) {\n        isPanning.current = true;\n        // Snapshot the current position of both mouse pointer and the element\n        startMousePosition.current = getEventXY(event);\n        prevPosition.current = { ...currentPosition.current };\n        setState((state) => ({ ...state, isPanning: true }));\n        bindEvents();\n      }\n    };\n\n    const stopPanning = () => {\n      if (isPanning.current && isMounted()) {\n        isPanning.current = false;\n        setState((state) => ({ ...state, isPanning: false }));\n        unbindEvents();\n      }\n    };\n\n    const onPanStart = (event: Event) => {\n      startPanning(event);\n      onPan(event);\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onPan);\n      document.addEventListener('mouseup', stopPanning);\n      document.addEventListener('touchmove', onPan);\n      document.addEventListener('touchend', stopPanning);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onPan);\n      document.removeEventListener('mouseup', stopPanning);\n      document.removeEventListener('touchmove', onPan);\n      document.removeEventListener('touchend', stopPanning);\n    };\n\n    const onPan = (event: Event) => {\n      cancelAnimationFrame(frame.current);\n      const pos = getEventXY(event);\n\n      frame.current = requestAnimationFrame(() => {\n        if (isMounted() && panRef.current) {\n          // Get the diff by which we moved the mouse.\n          let xDiff = pos.x - startMousePosition.current.x;\n          let yDiff = pos.y - startMousePosition.current.y;\n\n          // Add the diff to the position from the moment we started panning.\n          currentPosition.current = {\n            x: inBounds(prevPosition.current.x + xDiff / scale, viewBounds.left, viewBounds.right),\n            y: inBounds(prevPosition.current.y + yDiff / scale, viewBounds.top, viewBounds.bottom),\n          };\n          setState((state) => ({\n            ...state,\n            position: {\n              ...currentPosition.current,\n            },\n          }));\n        }\n      });\n    };\n\n    const ref = panRef.current;\n    if (ref) {\n      ref.addEventListener('mousedown', onPanStart);\n      ref.addEventListener('touchstart', onPanStart);\n    }\n    return () => {\n      if (ref) {\n        ref.removeEventListener('mousedown', onPanStart);\n        ref.removeEventListener('touchstart', onPanStart);\n      }\n    };\n  }, [scale, viewBounds, isMounted]);\n\n  const previousFocus = usePrevious(focus);\n\n  // We need to update the state in case need to focus on something but we want to do it only once when the focus\n  // changes to something new.\n  useEffect(() => {\n    if (focus && previousFocus?.x !== focus.x && previousFocus?.y !== focus.y) {\n      const position = {\n        x: inBounds(focus.x, viewBounds.left, viewBounds.right),\n        y: inBounds(focus.y, viewBounds.top, viewBounds.bottom),\n      };\n      setState({\n        position,\n        isPanning: false,\n      });\n\n      currentPosition.current = position;\n      prevPosition.current = position;\n    }\n  }, [focus, previousFocus, viewBounds, currentPosition, prevPosition]);\n\n  let position = state.position;\n  // This part prevents an ugly jump from initial position to the focused one as the set state in the effects is after\n  // initial render.\n  if (focus && previousFocus?.x !== focus.x && previousFocus?.y !== focus.y) {\n    position = focus;\n  }\n\n  return {\n    state: {\n      ...state,\n      position: {\n        x: inBounds(position.x, viewBounds.left, viewBounds.right),\n        y: inBounds(position.y, viewBounds.top, viewBounds.bottom),\n      },\n    },\n    ref: panRef,\n  };\n}\n\nfunction inBounds(value: number, min: number | undefined, max: number | undefined) {\n  return Math.min(Math.max(value, min ?? -Infinity), max ?? Infinity);\n}\n\n// The issue here is that TouchEvent is undefined while using instanceof in Firefox and Safari\n// which will throw an exception but if it's event.changedTouches it will be undefined\n// and the if check will fail so it will go to the else but will not throw an exception\nfunction getEventXY(event: Event): { x: number; y: number } {\n  if ('changedTouches' in event && event instanceof TouchEvent) {\n    return { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY };\n  } else if (event instanceof MouseEvent) {\n    return { x: event.clientX, y: event.clientY };\n  }\n  return { x: 0, y: 0 };\n}\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nexport interface ArcOption {\n  /**\n   * The color of the arc.\n   */\n  color?: string;\n  /**\n   * Field from which to get the value. Values should be less than 1, representing fraction of a circle.\n   */\n  field?: string;\n}\n\nexport enum ZoomMode {\n  Cooperative = 'cooperative',\n  Greedy = 'greedy',\n}\n\nexport interface Options {\n  edges?: {\n    /**\n     * Unit for the main stat to override what ever is set in the data frame.\n     */\n    mainStatUnit?: string;\n    /**\n     * Unit for the secondary stat to override what ever is set in the data frame.\n     */\n    secondaryStatUnit?: string;\n  };\n  nodes?: {\n    /**\n     * Unit for the main stat to override what ever is set in the data frame.\n     */\n    mainStatUnit?: string;\n    /**\n     * Unit for the secondary stat to override what ever is set in the data frame.\n     */\n    secondaryStatUnit?: string;\n    /**\n     * Define which fields are shown as part of the node arc (colored circle around the node).\n     */\n    arcs?: Array<ArcOption>;\n  };\n  /**\n   * How to handle zoom/scroll events in the node graph\n   */\n  zoomMode?: ZoomMode;\n}\n","import { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { ZoomMode } from './panelcfg.gen';\n\nconst defaultOptions: Required<Options> = {\n  stepUp: (s) => s * 1.5,\n  stepDown: (s) => s / 1.5,\n  min: 0.13,\n  max: 2.25,\n  zoomMode: ZoomMode.Cooperative,\n};\n\ninterface Options {\n  /**\n   * Allows you to specify how the step up will be handled so you can do fractional steps based on previous value.\n   */\n  stepUp?: (scale: number) => number;\n  stepDown?: (scale: number) => number;\n\n  /**\n   * Set max and min values. If stepUp/down overshoots these bounds this will return min or max but internal scale value\n   * will still be what ever the step functions returned last.\n   */\n  min?: number;\n  max?: number;\n\n  /**\n   * Sets how to handle zoom events when user is interacting with the page\n   */\n  zoomMode?: ZoomMode;\n}\n\n/**\n * Keeps state and returns handlers that can be used to implement zooming functionality ideally by using it with\n * 'transform: scale'. It returns handler for manual buttons with zoom in/zoom out function and a ref that can be\n * used to zoom in/out with mouse wheel.\n */\nexport function useZoom(options: Options = defaultOptions) {\n  const { min, max, zoomMode } = { ...defaultOptions, ...options };\n  const stepUp = options.stepUp ?? defaultOptions.stepUp;\n  const stepDown = options.stepDown ?? defaultOptions.stepDown;\n\n  const ref = useRef<HTMLElement | null>(null);\n  const [scale, setScale] = useState(1);\n\n  const onStepUp = useCallback(() => {\n    if (scale < (max ?? Infinity)) {\n      setScale(stepUp(scale));\n    }\n  }, [scale, stepUp, max]);\n\n  const onStepDown = useCallback(() => {\n    if (scale > (min ?? -Infinity)) {\n      setScale(stepDown(scale));\n    }\n  }, [scale, stepDown, min]);\n\n  const onWheel = useCallback(\n    function (wheelEvent: WheelEvent) {\n      // Seems like typing for the addEventListener is lacking a bit\n\n      // Only do this with special key pressed similar to how google maps work.\n      // TODO: I would guess this won't work very well with touch right now\n      if (wheelEvent.ctrlKey || wheelEvent.metaKey || zoomMode === ZoomMode.Greedy) {\n        wheelEvent.preventDefault();\n\n        setScale(Math.min(Math.max(min ?? -Infinity, scale + Math.min(wheelEvent.deltaY, 2) * -0.01), max ?? Infinity));\n\n        if (wheelEvent.deltaY < 0) {\n          const newScale = scale + Math.max(wheelEvent.deltaY, -4) * -0.015;\n          setScale(Math.max(min ?? -Infinity, newScale));\n        } else if (wheelEvent.deltaY > 0) {\n          const newScale = scale + Math.min(wheelEvent.deltaY, 4) * -0.015;\n          setScale(Math.min(max ?? Infinity, newScale));\n        }\n      }\n    },\n    [min, max, scale, zoomMode]\n  );\n\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n\n    const zoomRef = ref.current;\n\n    // Adds listener for wheel event, we need the passive: false to be able to prevent default otherwise that\n    // cannot be used with passive listeners.\n    zoomRef.addEventListener('wheel', onWheel, { passive: false });\n    return () => {\n      if (zoomRef) {\n        zoomRef.removeEventListener('wheel', onWheel);\n      }\n    };\n  }, [onWheel]);\n\n  return {\n    onStepUp,\n    onStepDown,\n    scale: Math.max(Math.min(scale, max ?? Infinity), min ?? -Infinity),\n    isMax: scale >= (max ?? Infinity),\n    isMin: scale <= (min ?? -Infinity),\n    ref,\n  };\n}\n","import { css } from '@emotion/css';\nimport cx from 'classnames';\nimport { memo, MouseEvent, useCallback, useEffect, useMemo, useState } from 'react';\nimport useMeasure from 'react-use/lib/useMeasure';\n\nimport { DataFrame, GrafanaTheme2, LinkModel } from '@grafana/data';\nimport { Icon, Spinner, useStyles2 } from '@grafana/ui';\n\nimport { Edge } from './Edge';\nimport { EdgeLabel } from './EdgeLabel';\nimport { Legend } from './Legend';\nimport { Marker } from './Marker';\nimport { Node } from './Node';\nimport { ViewControls } from './ViewControls';\nimport { Config, defaultConfig, useLayout } from './layout';\nimport { EdgeDatumLayout, NodeDatum, NodesMarker, ZoomMode } from './types';\nimport { useCategorizeFrames } from './useCategorizeFrames';\nimport { useContextMenu } from './useContextMenu';\nimport { useFocusPositionOnLayout } from './useFocusPositionOnLayout';\nimport { useHighlight } from './useHighlight';\nimport { usePanning } from './usePanning';\nimport { useZoom } from './useZoom';\nimport { processNodes, Bounds, findConnectedNodesForEdge, findConnectedNodesForNode } from './utils';\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    label: 'wrapper',\n    height: '100%',\n    width: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n  }),\n\n  svg: css({\n    label: 'svg',\n    height: '100%',\n    width: '100%',\n    overflow: 'visible',\n    fontSize: '10px',\n    cursor: 'move',\n  }),\n\n  svgPanning: css({\n    label: 'svgPanning',\n    userSelect: 'none',\n  }),\n\n  noDataMsg: css({\n    height: '100%',\n    width: '100%',\n    display: 'grid',\n    placeItems: 'center',\n    fontSize: theme.typography.h4.fontSize,\n    color: theme.colors.text.secondary,\n  }),\n\n  mainGroup: css({\n    label: 'mainGroup',\n    willChange: 'transform',\n  }),\n\n  viewControls: css({\n    label: 'viewControls',\n    position: 'absolute',\n    left: '2px',\n    bottom: '3px',\n    right: 0,\n    display: 'flex',\n    alignItems: 'flex-end',\n    justifyContent: 'space-between',\n    pointerEvents: 'none',\n  }),\n  legend: css({\n    label: 'legend',\n    background: theme.colors.background.secondary,\n    boxShadow: theme.shadows.z1,\n    paddingBottom: '5px',\n    marginRight: '10px',\n  }),\n  viewControlsWrapper: css({\n    marginLeft: 'auto',\n  }),\n  alert: css({\n    label: 'alert',\n    padding: '5px 8px',\n    fontSize: '10px',\n    textShadow: '0 1px 0 rgba(0, 0, 0, 0.2)',\n    borderRadius: theme.shape.radius.default,\n    alignItems: 'center',\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    background: theme.colors.warning.main,\n    color: theme.colors.warning.contrastText,\n  }),\n  loadingWrapper: css({\n    label: 'loadingWrapper',\n    height: '100%',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n  }),\n});\n\n// Limits the number of visible nodes, mainly for performance reasons. Nodes above the limit are accessible by expanding\n// parts of the graph. The specific number is arbitrary but should be a number of nodes where panning, zooming and other\n// interactions will be without any lag for most users.\nconst defaultNodeCountLimit = 200;\n\ninterface Props {\n  dataFrames: DataFrame[];\n  getLinks: (dataFrame: DataFrame, rowIndex: number) => LinkModel[];\n  nodeLimit?: number;\n  panelId?: string;\n  zoomMode?: ZoomMode;\n}\nexport function NodeGraph({ getLinks, dataFrames, nodeLimit, panelId, zoomMode }: Props) {\n  const nodeCountLimit = nodeLimit || defaultNodeCountLimit;\n  const { edges: edgesDataFrames, nodes: nodesDataFrames } = useCategorizeFrames(dataFrames);\n\n  const [measureRef, { width, height }] = useMeasure();\n  const [config, setConfig] = useState<Config>(defaultConfig);\n\n  const firstNodesDataFrame = nodesDataFrames[0];\n  const firstEdgesDataFrame = edgesDataFrames[0];\n\n  // Ensure we use unique IDs for the marker tip elements, since IDs are global\n  // in the entire HTML document. This prevents hidden tips when an earlier\n  // occurence is hidden (editor is open in front of an existing node graph\n  // panel) or when the earlier tips have different properties (color, size, or\n  // shape for example).\n  const svgIdNamespace = panelId || 'nodegraphpanel';\n\n  // TODO we should be able to allow multiple dataframes for both edges and nodes, could be issue with node ids which in\n  //  that case should be unique or figure a way to link edges and nodes dataframes together.\n  const processed = useMemo(\n    () => processNodes(firstNodesDataFrame, firstEdgesDataFrame),\n    [firstEdgesDataFrame, firstNodesDataFrame]\n  );\n\n  // We need hover state here because for nodes we also highlight edges and for edges have labels separate to make\n  // sure they are visible on top of everything else\n  const { nodeHover, setNodeHover, clearNodeHover, edgeHover, setEdgeHover, clearEdgeHover } = useHover();\n  const [hoveringIds, setHoveringIds] = useState<string[]>([]);\n  useEffect(() => {\n    let linked: string[] = [];\n    if (nodeHover) {\n      linked = findConnectedNodesForNode(processed.nodes, processed.edges, nodeHover);\n    } else if (edgeHover) {\n      linked = findConnectedNodesForEdge(processed.nodes, processed.edges, edgeHover);\n    }\n    setHoveringIds(linked);\n  }, [nodeHover, edgeHover, processed]);\n\n  // This is used for navigation from grid to graph view. This node will be centered and briefly highlighted.\n  const [focusedNodeId, setFocusedNodeId] = useState<string>();\n  const setFocused = useCallback((e: MouseEvent, m: NodesMarker) => setFocusedNodeId(m.node.id), [setFocusedNodeId]);\n\n  // May seem weird that we do layout first and then limit the nodes shown but the problem is we want to keep the node\n  // position stable which means we need the full layout first and then just visually hide the nodes. As hiding/showing\n  // nodes should not have effect on layout it should not be recalculated.\n  const { nodes, edges, markers, bounds, hiddenNodesCount, loading } = useLayout(\n    processed.nodes,\n    processed.edges,\n    config,\n    nodeCountLimit,\n    width,\n    focusedNodeId,\n    processed.hasFixedPositions\n  );\n\n  // If we move from grid to graph layout, and we have focused node lets get its position to center there. We want to\n  // do it specifically only in that case.\n  const focusPosition = useFocusPositionOnLayout(config, nodes, focusedNodeId);\n  const { panRef, zoomRef, onStepUp, onStepDown, isPanning, position, scale, isMaxZoom, isMinZoom } = usePanAndZoom(\n    bounds,\n    focusPosition,\n    zoomMode\n  );\n\n  const { onEdgeOpen, onNodeOpen, MenuComponent } = useContextMenu(\n    getLinks,\n    firstNodesDataFrame,\n    firstEdgesDataFrame,\n    config,\n    setConfig,\n    setFocusedNodeId\n  );\n  const styles = useStyles2(getStyles);\n\n  // This cannot be inline func, or it will create infinite render cycle.\n  const topLevelRef = useCallback(\n    (r: HTMLDivElement) => {\n      measureRef(r);\n      zoomRef.current = r;\n    },\n    [measureRef, zoomRef]\n  );\n\n  const highlightId = useHighlight(focusedNodeId);\n\n  return (\n    <div ref={topLevelRef} className={styles.wrapper}>\n      {loading ? (\n        <div className={styles.loadingWrapper}>\n          Computing layout&nbsp;\n          <Spinner />\n        </div>\n      ) : null}\n\n      {dataFrames.length && processed.nodes.length ? (\n        <svg\n          ref={panRef}\n          viewBox={`${-(width / 2)} ${-(height / 2)} ${width} ${height}`}\n          className={cx(styles.svg, isPanning && styles.svgPanning)}\n        >\n          <g\n            className={styles.mainGroup}\n            style={{ transform: `scale(${scale}) translate(${Math.floor(position.x)}px, ${Math.floor(position.y)}px)` }}\n          >\n            {!config.gridLayout && (\n              <Edges\n                edges={edges}\n                nodeHoveringId={nodeHover}\n                edgeHoveringId={edgeHover}\n                onClick={onEdgeOpen}\n                onMouseEnter={setEdgeHover}\n                onMouseLeave={clearEdgeHover}\n                svgIdNamespace={svgIdNamespace}\n              />\n            )}\n            <Nodes\n              nodes={nodes}\n              onMouseEnter={setNodeHover}\n              onMouseLeave={clearNodeHover}\n              onClick={onNodeOpen}\n              hoveringIds={hoveringIds || [highlightId]}\n            />\n\n            <Markers markers={markers || []} onClick={setFocused} />\n            {/*We split the labels from edges so that they are shown on top of everything else*/}\n            {!config.gridLayout && <EdgeLabels edges={edges} nodeHoveringId={nodeHover} edgeHoveringId={edgeHover} />}\n          </g>\n        </svg>\n      ) : (\n        <div className={styles.noDataMsg}>No data</div>\n      )}\n\n      <div className={styles.viewControls}>\n        {nodes.length ? (\n          <div className={styles.legend}>\n            <Legend\n              sortable={config.gridLayout}\n              nodes={nodes}\n              sort={config.sort}\n              onSort={(sort) => {\n                setConfig({\n                  ...config,\n                  sort: sort,\n                });\n              }}\n            />\n          </div>\n        ) : null}\n\n        <div className={styles.viewControlsWrapper}>\n          <ViewControls<Config>\n            config={config}\n            onConfigChange={(cfg) => {\n              if (cfg.gridLayout !== config.gridLayout) {\n                setFocusedNodeId(undefined);\n              }\n              setConfig(cfg);\n            }}\n            onMinus={onStepDown}\n            onPlus={onStepUp}\n            scale={scale}\n            disableZoomIn={isMaxZoom}\n            disableZoomOut={isMinZoom}\n          />\n        </div>\n      </div>\n\n      {hiddenNodesCount > 0 && (\n        <div className={styles.alert} aria-label={'Nodes hidden warning'}>\n          <Icon size=\"sm\" name={'info-circle'} /> {hiddenNodesCount} nodes are hidden for performance reasons.\n        </div>\n      )}\n\n      {MenuComponent}\n    </div>\n  );\n}\n\n// Active -> emphasized, inactive -> de-emphasized, and default -> normal styling\nexport type HoverState = 'active' | 'inactive' | 'default';\n\n// These components are here as a perf optimisation to prevent going through all nodes and edges on every pan/zoom.\ninterface NodesProps {\n  nodes: NodeDatum[];\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n  onClick: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n  hoveringIds?: string[];\n}\nconst Nodes = memo(function Nodes(props: NodesProps) {\n  return (\n    <>\n      {props.nodes.map((n) => (\n        <Node\n          key={n.id}\n          node={n}\n          onMouseEnter={props.onMouseEnter}\n          onMouseLeave={props.onMouseLeave}\n          onClick={props.onClick}\n          hovering={\n            !props.hoveringIds || props.hoveringIds.length === 0\n              ? 'default'\n              : props.hoveringIds?.includes(n.id)\n                ? 'active'\n                : 'inactive'\n          }\n        />\n      ))}\n    </>\n  );\n});\n\ninterface MarkersProps {\n  markers: NodesMarker[];\n  onClick: (event: MouseEvent<SVGElement>, marker: NodesMarker) => void;\n}\nconst Markers = memo(function Nodes(props: MarkersProps) {\n  return (\n    <>\n      {props.markers.map((m) => (\n        <Marker key={'marker-' + m.node.id} marker={m} onClick={props.onClick} />\n      ))}\n    </>\n  );\n});\n\ninterface EdgesProps {\n  edges: EdgeDatumLayout[];\n  nodeHoveringId?: string;\n  edgeHoveringId?: string;\n  svgIdNamespace: string;\n  onClick: (event: MouseEvent<SVGElement>, link: EdgeDatumLayout) => void;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n}\nconst Edges = memo(function Edges(props: EdgesProps) {\n  return (\n    <>\n      {props.edges.map((e) => (\n        <Edge\n          key={e.id}\n          edge={e}\n          hovering={\n            (e.source as NodeDatum).id === props.nodeHoveringId ||\n            (e.target as NodeDatum).id === props.nodeHoveringId ||\n            props.edgeHoveringId === e.id\n          }\n          onClick={props.onClick}\n          onMouseEnter={props.onMouseEnter}\n          onMouseLeave={props.onMouseLeave}\n          svgIdNamespace={props.svgIdNamespace}\n        />\n      ))}\n    </>\n  );\n});\n\ninterface EdgeLabelsProps {\n  edges: EdgeDatumLayout[];\n  nodeHoveringId?: string;\n  edgeHoveringId?: string;\n}\nconst EdgeLabels = memo(function EdgeLabels(props: EdgeLabelsProps) {\n  return (\n    <>\n      {props.edges.map((e, index) => {\n        // We show the edge label in case user hovers over the edge directly or if they hover over node edge is\n        // connected to.\n        const shouldShow =\n          (e.source as NodeDatum).id === props.nodeHoveringId ||\n          (e.target as NodeDatum).id === props.nodeHoveringId ||\n          props.edgeHoveringId === e.id;\n\n        const hasStats = e.mainStat || e.secondaryStat;\n        return shouldShow && hasStats && <EdgeLabel key={e.id} edge={e} />;\n      })}\n    </>\n  );\n});\n\nfunction usePanAndZoom(bounds: Bounds, focus?: { x: number; y: number }, zoomMode?: ZoomMode) {\n  const { scale, onStepDown, onStepUp, ref, isMax, isMin } = useZoom({ zoomMode });\n  const { state: panningState, ref: panRef } = usePanning<SVGSVGElement>({\n    scale,\n    bounds,\n    focus,\n  });\n  const { position, isPanning } = panningState;\n  return { zoomRef: ref, panRef, position, isPanning, scale, onStepDown, onStepUp, isMaxZoom: isMax, isMinZoom: isMin };\n}\n\nfunction useHover() {\n  const [nodeHover, setNodeHover] = useState<string | undefined>(undefined);\n  const clearNodeHover = useCallback(() => setNodeHover(undefined), [setNodeHover]);\n  const [edgeHover, setEdgeHover] = useState<string | undefined>(undefined);\n  const clearEdgeHover = useCallback(() => setEdgeHover(undefined), [setEdgeHover]);\n\n  return { nodeHover, setNodeHover, clearNodeHover, edgeHover, setEdgeHover, clearEdgeHover };\n}\n","import { useMemo } from 'react';\n\nimport { DataFrame } from '@grafana/data';\n\nimport { getGraphFrame } from './utils';\n\n/**\n * As we need 2 dataframes for the service map, one with nodes and one with edges we have to figure out which is which.\n * Right now we do not have any metadata for it so we just check preferredVisualisationType and then column names.\n * TODO: maybe we could use column labels to have a better way to do this\n */\nexport function useCategorizeFrames(series: DataFrame[]) {\n  return useMemo(() => {\n    return getGraphFrame(series);\n  }, [series]);\n}\n"],"names":["EdgeArrowMarker","id","fill","defaultEdgeColor","headHeight","defaultHighlightedEdgeColor","Edge","props","edge","onClick","onMouseEnter","onMouseLeave","hovering","svgIdNamespace","source","target","sourceNodeRadius","targetNodeRadius","arrowHeadHeight","line","edgeColor","highlightedEdgeColor","markerId","coloredMarkerId","event","getStyles","theme","EdgeLabel","middle","styles","stats","x","height","middleOffset","offset","contents","stat","index","Legend","nodes","onSort","sort","sortable","colorItems","getColorLegendItems","item","VizLegend","VizLegendListItem","Icon","fields","node","n","f","nodeR","Marker","marker","ViewControls","config","onConfigChange","onPlus","onMinus","disableZoomOut","disableZoomIn","showConfig","setShowConfig","allowConfiguration","Button","k","e","createWorker","createMsaglWorker","useNodeLimit","edges","limit","rootId","edgesMap","nodesMap","acc","limitGridLayout","limitGraphLayout","roots","visibleNodes","markers","collectVisibleNodes","markersWithStats","collectMarkerStats","markersMap","m","visibleEdges","start","stop","prevLimit","afterLimit","stack","current","connectedNodes","nodesToCount","count","defaultConfig","useLayout","rawNodes","rawEdges","nodeCountLimit","width","rootNodeId","hasFixedPositions","nodesGraph","setNodesGraph","edgesGraph","setEdgesGraph","loading","setLoading","isMounted","useMountedState","layoutWorkerCancelRef","useUnmount","layoutType","cancel","layout","nodesGrid","edgesGrid","rawNodesCopy","rawEdgesCopy","gridLayout","nodesWithLimit","edgesWithLimit","bounds","engine","done","worker","perRow","midPoint","node1","node2","val1","val2","row","column","useContextMenu","getLinks","setConfig","setFocusedNodeId","menu","setMenu","onNodeOpen","label","showGridLayout","extraNodeItem","links","renderer","getItemsRenderer","makeContextMenu","NodeHeader","EdgeHeader","header","ContextMenu","extraItems","items","getItems","groups","group","MenuGroup","mapMenuItem","link","MenuItem","defaultGroup","l","title","key","FieldRow","field","HeaderRow","value","getLabelStyles","rows","valueSource","valueTarget","useFocusPositionOnLayout","focusedNodeId","prevLayoutGrid","usePrevious","focusPosition","useHighlight","highlightId","setHighlightId","mounted","usePanning","scale","focus","isPanning","frame","panRef","initial","viewBounds","startMousePosition","prevPosition","currentPosition","state","setState","startPanning","getEventXY","bindEvents","stopPanning","unbindEvents","onPanStart","onPan","pos","xDiff","yDiff","inBounds","ref","previousFocus","position","min","max","ZoomMode","defaultOptions","s","useZoom","options","zoomMode","stepUp","stepDown","setScale","onStepUp","onStepDown","onWheel","wheelEvent","newScale","zoomRef","defaultNodeCountLimit","NodeGraph","dataFrames","nodeLimit","panelId","edgesDataFrames","nodesDataFrames","useCategorizeFrames","measureRef","useMeasure","firstNodesDataFrame","firstEdgesDataFrame","processed","nodeHover","setNodeHover","clearNodeHover","edgeHover","setEdgeHover","clearEdgeHover","useHover","hoveringIds","setHoveringIds","linked","setFocused","hiddenNodesCount","isMaxZoom","isMinZoom","usePanAndZoom","onEdgeOpen","MenuComponent","topLevelRef","r","Spinner","Edges","Nodes","Markers","EdgeLabels","cfg","Node","shouldShow","hasStats","isMax","isMin","panningState","series"],"sourceRoot":""}